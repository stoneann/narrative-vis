{"nodes": [{"id": 1519, "value": "Unfortunately, we cannot reveal the contents of private test cases to students. However, feel free to come to office hours so an instructor can help look at your code.\u00a0"}, {"id": 1520, "value": "You've failed some private test cases for insert, erase, and the assignment operator."}, {"id": 1521, "value": "Canvas should eventually reflect your true score"}, {"id": 1522, "value": "I took a look at your code and found a problem that could be the reason.. In == and != operators, you compared datum instead of node_ptr to check if two iterators are equal or not. However, two iterators are equal if they point to the same node and not equal otherwise. If two iterators point to the same node, then they always have the same datum, but the reverse is generally not true.. I guess most private test cases use these two operators, even if they are not explicitly testing them, which could be why many test cases didn't pass.. I'm sorry that this happened to you."}, {"id": 1523, "value": "It's possible that your 58/63 submission passed more private tests than your 61/63 submission, leading that to be the final score."}, {"id": 1524, "value": "While I agree with your point that writing test cases is to catch bugs, not having the instructors asking you to write and grading those test cases does not prevent you from writing your own private tests to catch bugs. I'm sure this will become more common in ULCS courses as well as in the industry as a software engineer. I understand that you are disappointed with your api.cpp private test score, but I do not believe it is the instructor's issue here, since it did not prevent you from testing it yourself to make sure you have working code. In addition, Autograder did disclose it would run private tests on api.cpp, so this wasn't really a surprise.. "}, {"id": 1525, "value": "Consider what happens if we want to insert a node at the end of the list, and thus pass in an iterator returned from List::end() (we want to insert before the iterator, which is currently at one past the end, so we're effectively inserting at the end). Thus, the iterator's node pointer is nullptr. This is a valid input, as the iterator passed in must simply be a \"valid iterator associated with this list,\" and doesn't have to be dereferencable like in other functions (such as erase()). Does your else{} block handle this input correctly? It looks like it'll try to dereference a nullptr by accessing n->prev."}, {"id": 1526, "value": "For p4. you can write you own private tests by making your own test files by inputting GET, POST, and DELETE requests and seeing what it outputs and see if it matches what the spec wants these requests to do.\u00a0. . And you should always aim for full score on the autograder to ensure that you get a high score on the private tests."}, {"id": 1527, "value": "Could you make sure that your `Student` object, `sonia` is valid (i.e. both `location` and `uniqname` are valid) after line 115?"}, {"id": 1528, "value": "Unfortunately, we cannot show the content of private test cases. But, you can come to office hours so a member of staff can help look at your code.\u00a0"}, {"id": 1529, "value": "I've taken a look at your DELETE() function, and it looks like it's missing some logic for looping over the remaining students in the queue, and decrementing their positions. I understand why you feel disappointed with yourself, but remember that a single project (or, more specifically, one requirement from one part of one project) cannot possibly represent your ability or value as a scholar; if you've made \"stupid\" mistakes before, you're certainly in good company. ;). . In terms of potential implementations for this requirement, I recommend using some sort of for loop (either using an iterator, or a for-each loop with references) that accesses each each Student in the queue, and decrements their position member. I prefer for-each loops for tasks like this; they generally look like this:. . for (Student &stu : queue) { // notice stu is a reference!. // do something in here. }. . I'm sorry you didn't get the grade you wanted. On my first attempt of the driver, I completely overlooked the position decrement requirement. I'll pass this feedback on to the rest of the staff so we can clarify this detail in the spec."}, {"id": 1530, "value": "Just adding my two cents: Remember that you can't really show your interviewer your code (due to likely time constraints and the Honor Code, though we cannot really enforce the latter here), so the specifics of your implementation aren't all that important for impressing your interviewer. In my experience, interviewers are more interested in how you achieved something rather than what you achieved, as well as what you learned from the experience. For example, rather than simply discussing the implementation details of P3 or P4, I'd focus on the software engineering process. These details are typically beyond the scope of EECS 280, but some important things to consider:. Did you work with someone else? If so, how'd you manage the collaboration? If hired, you'll almost certainly be working with other people, so your collaboration and communication skills are vital to your success!How did you plan your implementation before beginning it?How did you go about testing your code?What debugging strategies did you employ?What roadblocks did you encounter along the way, and how did you overcome them?How did you manage your time amidst your busy schedule?After finishing the project(s), what did you learn from the experience? If you had to do the whole project again, what would you do differently? (For example, would you write tests before implementing functions? Use pair-programming with your partner? etc). Regardless of whether you're interviewing for industry positions or not, these learnings can also help you in future EECS projects, too. Best of luck in your interview!"}, {"id": 1531, "value": ""}, {"id": 1532, "value": "See here https://eecs280staff.github.io/p4-web/#real-web-server-optional. You basically need to run server.py with python and go to localhost:8000 in your web browser."}, {"id": 1533, "value": "Similar to the midterm exam, there are students with extensions due to medical emergencies, so it probably won't be until next week."}, {"id": 1534, "value": "I'm sorry, but for fairness reasons we can't do anything here. Your final grade will be based on whichever submission has the highest score, so if you have a previous submission that doesn't have the unsuppressed cout then that'll probably be used instead."}, {"id": 1535, "value": ""}, {"id": 1536, "value": "I checked your submission and it's a different issue that caused your last submission's tests to fail -- you do `ASSERT_TRUE(list101.end() == nullptr)` when the left-hand side is an iterator and the right-hand size is a poitner, which is a type mismatch."}, {"id": 1537, "value": "As a general tip for whether or not you need to handle edge cases like this, you should take a look at the requires clause:. . //REQUIRES: i is a valid, dereferenceable iterator associated with this list. "}, {"id": 1538, "value": "List_tests.cpp:190:25: error: variable \u2018iter2\u2019 set but not used"}, {"id": 1539, "value": "resolved"}, {"id": 1540, "value": "Converted to private. List.h line 264. You should not assert(*i) since *i returns a datum, which is type T not pointer."}, {"id": 1541, "value": "Memory leaks occur when your\u00a0dynamically allocated objects, the ones created by calling new, are not properly cleaned. Objects on the stack are automatically destroyed when the function goes out of scope."}, {"id": 1542, "value": "Most likely you didn't read in the JSON object right when you should be. (a little too early or a little too late) I'd suggest you use a debugger to make sure you've completely read in the header and started reading in JSON immediately afterwards."}, {"id": 1543, "value": "Yes"}, {"id": 1544, "value": "You are using postfix operator ++ in your test cases, which is not allowed since it is not overloaded."}, {"id": 1545, "value": "It appears that your\u00a0last\u00a0pointer is nullptr so it cannot be dereferenced to get\u00a0next\u00a0."}, {"id": 1546, "value": "If you were to immediately call the following:\"GET /api/queue/head/ HTTP/1.1Host: localhostContent-Type: application/json; charset=utf-8Content-Length: 0\"...then your queue would still be empty, (as no POST requests have been made yet) and a 400 error would be returned. The response would be:\"HTTP/1.1 400 Bad RequestContent-Type: application/json; charset=utf-8Content-Length: 0\""}, {"id": 1547, "value": "Resolved in followups."}, {"id": 1548, "value": "It is very difficult to make valgrind work on Mac, which is why we recommend a different solution (the `leaks` tool) for Mac: https://eecs280staff.github.io/tutorials/setup_leakcheck.html"}, {"id": 1549, "value": "Infinite loop, perhaps?"}, {"id": 1550, "value": "Converted question to private. At line 154 in List.h, you are asserting *i. Remember that *i returns the\u00a0datum of the node, not the node pointer, so you cannot assert it, which is of type T not a pointer."}, {"id": 1551, "value": "my uniqname is sreejav"}, {"id": 1552, "value": "If it\u2019s about catching bugs missing that one bug would reduce your overall score by only one point but it could make you more at risk for having more bugs in your list.h file if it has not been thoroughly tested\u00a0"}, {"id": 1553, "value": "It looks like you're trying to access a member variable of a nullptr. This is likely because you're trying to read something off the end of your list (either on the front or back), such as \"some_node->prev->next\", where \"some_node\" is the first node. This code will throw the error you're seeing here, since the previous node for \"some_node\" is a nullptr, which obviously doesn't have the member variable \"next\".I recommend running your test cases inside of your debugger, it should stop and show you where the issue is occurring in your code."}, {"id": 1554, "value": "There might be some undefined behavior that's causing this, I'd make sure that any variables that are supposed to be zero are explicitly set to 0."}, {"id": 1555, "value": "According to what I saw from your AG feedback, that is the only issue."}, {"id": 1556, "value": ""}, {"id": 1557, "value": "Student follow-up is correct. You just need to cout them like regular strings."}, {"id": 1558, "value": "resolved"}, {"id": 1559, "value": "Your iterator\u00a0it\u00a0on line 306 in List_tests.cpp is unused, thus giving the error. I highly recommend you run your program on CAEN before submitting to AG so you could catch errors like this without using a submission."}, {"id": 1560, "value": "Are you doing adding the new line character to the string that you print out because that could be the problem.\u00a0"}, {"id": 1561, "value": "I would take a look at List_tests.cpp line 603, since it seems like your memory leak is happening there.\u00a0"}, {"id": 1562, "value": "You shouldn't delete the new node in those function as much as those should be deleted in your destructor. This means that your destructor isn't deleting all the nodes in your linked list. Make sure if you are using a loop that it loop enough times.\u00a0"}, {"id": 1563, "value": "This happened to me as well. I guess the compiler knows that assigning an element to itself is dumb so it stops you from doing it.\u00a0 What I did to get around this was to make a pointer to the element and then used this pointer to assign the element to itself."}, {"id": 1564, "value": "It isn\u2019t an honor code violation. You can do this :)\u00a0"}, {"id": 1565, "value": "I can see how that image is confusing. I believe the addresses you pointed out are the addresses of the pointers themselves, and not the addresses they are pointing to. This is an image of what not to do to make a deep copy.\u00a0. . If your question is about testing if the copy made is deep or shallow, I would recommend using iterators. Assign a pre-built list (list1) to another list (list2) and set iterators to the first spot in both of them. The iterator == operation can then be used to check if they are pointing to the same spot in memory.. . Hope this helps!"}, {"id": 1566, "value": "Also, within the big three, try to remind yourself of WHY you need the big three in this case. What extra benefits do they provide in certain situations? Can you test those situations out? (general advice without looking through your code)"}, {"id": 1567, "value": "i have seen this error before, make sure you are not missing a semicolon right before a function definition"}, {"id": 1568, "value": "Your error is on List_tests.cpp:177 -- you shouldn't assert_equal between an iterator and null pointer. Instead, do ASSERT_TRUE(ptr == empty_list.end()). . Make sure you aren't comparing any iterators to null pointers anywhere in your tests."}, {"id": 1569, "value": ""}, {"id": 1570, "value": "I personally separated my requests into 3 different \"handle\" functions, such as \"handle_POST\", etc. From there, I have some if statements that handle each request endpoint for that method, and if it encounters something different, it throws an error."}, {"id": 1571, "value": "The problem is most likely that one of your overloading operators is returning a specific data type, rather than a template. Did you double-check that?. . For example, you might have written in your code:. int & operator*() {. \u00a0 \u00a0 \u00a0 //insert code. }. But this function should not be returning an int, but the type T (template).. So the correct formatting would be:. T & operator*() {. \u00a0 \u00a0 \u00a0 //insert code. }. Hope this helps!"}, {"id": 1572, "value": "Try this if you're on windows and you use Ubuntu:1.) Go to the folder where your cpp file is located.2.) Enter bash in the\u00a0top window.\u00a03.) Enter \"code .\" in the\u00a0command window\u00a0that pops up.VS Code should pop up showing \"Ubuntu WSL\" in the bottom left corner. If you see that, then you should be good to go!"}, {"id": 1573, "value": "You should not change the function signature, I would instead change your tests -- if the tests are invalid with the signature as-is, AG will mark them as a false positive anyway"}, {"id": 1574, "value": "No, you use std:list"}, {"id": 1575, "value": "Ok, from what I am gathering from the spec and the project is that you would only make an array of JSON objects, so you could display it. Also, when you are deleting something you would iterate through your linked list not the JSON array.\u00a0"}, {"id": 1576, "value": ""}, {"id": 1577, "value": "I just asked Prof. DeOrio about this in class -- The error this test case is testing for is whether you handle the invalid path `/invalid/path/`, not the content-length and body being present. . . **You will not be tested on whether there is a request body/content length in `GET` requests.** You can either give a 400 error if there is a request body, or you can silently \"consume\" it and ignore it."}, {"id": 1578, "value": "It's essentially saying that you called delete on a dynamically allocated object you created and somewhere else in your code you go back and delete that dead object again calling a double delete. Check to make sure you didn't accidentally delete the same object twice or have some helper function which is deleting it.\u00a0"}, {"id": 1579, "value": "Well, the point of this operator of List = is to make it where you can set a list to equal another. Knowing this, you know that if your operator works properly that both lists should be copies of each other. This would mean they should have the same size, and elements. These observable characteristics are where you can make some tests for the operator.\u00a0\u00a0. . Then for your second operator is the dereference operator. This is supposed to give you the datum of a given node. Knowing this, you could make a list with some elements and then test if you dereference a node that it gives you the proper datum.\u00a0. . I hope this helps you!\u00a0"}, {"id": 1580, "value": "Remember that a linked list is not like a normal array in the sense that it is not sequential in memory so delete[] would not be the way to delete the list. If you just delete the first node, the remaining nodes will still be there and there will be a memory leak as you could not be able to access the rest. You should think about using a certain function to remove every item individually which you probably implemented before the assignment overloading function. Also the condition you are talking about should be handled in that one function."}, {"id": 1581, "value": "I think it is for post api/tail. Try returning the size of the queue in the position\u00a0"}, {"id": 1582, "value": "Just took a look at your autograder and it looks like you figured this out?"}, {"id": 1583, "value": "resolved"}, {"id": 1584, "value": ""}, {"id": 1585, "value": "The copy constructor is trying to access the datum of a Node that doesn't exist or doesn't exist anymore. This is probably because the next (or prev) points to something other than a nullptr, so the Iterator continues the valid list and tries to copy from uninitialized memory. Check in the debugger for whether next points to 0x0 for the last Node in the list during the copying function. If not, there is likely a problem with any function that modifies the list e.g. push and pop. Make sure to consider cases where the affected Node is the only Node in a list, the first in a list, the last in a list, etc. It it does, I would check the condition on which the function stops copying."}, {"id": 1586, "value": ""}, {"id": 1587, "value": "Check line 311 of your list.h: dereferencing the iterator and comparing it to a value in your list will not check that they're pointing to the same object. Instead, try another method, such as checking if (i == last) to achieve the same goal. This way you are directly comparing two iterators."}, {"id": 1588, "value": "Just took a look and it looks like you figured this out -- for other students, the error here was caused by declaring iterators and not using them in the test cases"}, {"id": 1589, "value": "resolved"}, {"id": 1590, "value": "Your issue is that you have declared iterators on lines 151 and 240 and did not use them in your tests. This is causing your tests to not compile on AG. I suggest you remove these lines.. . For other students struggling with this, I posted on @3686 with some common errors I've seen regarding this issue.. . "}, {"id": 1591, "value": "Thanks for your question. The EECS 280 policy for reusing code from previous semesters is as follows:. . If you choose to work alone, you are free to reuse your own code from a previous term. However, if you choose to work with a partner for the next term, you're not allowed to reuse code from a previous term.\u00a0"}, {"id": 1592, "value": ""}, {"id": 1593, "value": "You have the following error in your test cases:\u00a0"}, {"id": 1594, "value": "The autograder displays 'No test cases submitted' when the tests do not compile. Some common mistakes I've seen include accessing the private iterator constructor, creating helper functions \u00a0in list.h and calling them in your tests (don't do this -- it's running your tests against the instructor solution and they don't have your same helper functions defined), doing ASSERT_EQUAL(it, nullptr) rather than ASSERT_TRUE(it == list.end()), and defining iterators but not using them. (I responded to your post privately about what your specific issue is)."}, {"id": 1595, "value": ". . . . The requires clause specifies what the function assumes about its parameters. So, while you are not completely wrong in your assert statement, you do not need to explicitly check for the condition specified by the requires clause in your function implementation.\u00a0. . . . "}, {"id": 1596, "value": "if you look up the type_error305 in the documentation for the json library, you should be able to figure out where your bug is. here is the link to an explanation of the error: https://docs.ros.org/en/melodic/api/json_transport/html/classnlohmann_1_1detail_1_1type__error.html. . if you read through the documentation for how to use the json properly or in the summary in the project specs, you should be able to follow it and not encounter this error anymore."}, {"id": 1597, "value": "you should be creating a constructor for Node. NOTE: push_front is providing you with datum as a parameter."}, {"id": 1598, "value": ""}, {"id": 1599, "value": "what is the error you are getting? you should include it with your post.. . make sure you are including the proper template heading directly above your class definition:. . template <typename T>. class List { ..."}, {"id": 1600, "value": "Your error is that you are calling what appears to be a helper function in your list_tests, which won't compile when run against the instructor solution:"}, {"id": 1601, "value": "resolved."}, {"id": 1602, "value": "you can write your operator override for list inside of the public: section of the List class. if you do this, you may remove List<T>::"}, {"id": 1603, "value": ""}, {"id": 1604, "value": "you do not need to write your own tests for API. if you are asking if there are private tests which will be graded in the autograder, the answer is yes. these will only be seen after the project submission deadline. you may still check your API.cpp code against the public tests which are provided in the project folder and in the autograder."}, {"id": 1605, "value": "this exact error happened to me too, in my case i was iterating into undefined memory w/o realizing & vscode didn\u2019t catch it, so i\u2019d recommend to check all the pointers & loops in that test case"}, {"id": 1606, "value": "If you remove the submission while in the queue, it will not count as a submission\u00a0"}, {"id": 1607, "value": "make sure you are ONLY using the prefix ++. you cannot use the suffix.. . you can use:. for(size_t i = 0; i < foo.size(); ++i){bar();}. . you cannot use:. for(size_t i = 0; i < foo.size(); i++){bar();}"}, {"id": 1608, "value": "yes. in accordance with the project specs and the documentation for json in c++, you should also include:. . using nlohmann::json;"}, {"id": 1609, "value": "i figure it out: i was missing a Node constructor"}, {"id": 1610, "value": "not sure how the json::array() thing works, but you can also just make a json array by just pushing in other json objects.. . json array;. json something;. array.push_back(something). . some more details are in the json references section of the p4 spec"}, {"id": 1611, "value": "In your output you are getting a hexadecimal address so that means that you are printing out a ptr or the memory address of an object. Go take a look at your cout statement and comb through it. Sometimes if I can't find it then I just rewrite the cout statement and see if that changes anything.\u00a0"}, {"id": 1612, "value": ""}, {"id": 1613, "value": "High ncss means that you have 43 \"non-commenting source statements\" (aka 'useful lines') in your method, but the limit is 40.\u00a0. . Basically, this is how it counts:. . void example() \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// 1. {. \u00a0 \u00a0 if (1) \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// 2. \u00a0 \u00a0 {. \u00a0 \u00a0 }. \u00a0 \u00a0 else \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// 3. \u00a0 \u00a0 {. \u00a0 \u00a0 }. }. . So, shorten ur method or add a helper method."}, {"id": 1614, "value": ""}, {"id": 1615, "value": "If you are calling queue.size it should be returning an integer. If it is giving you a warning, you could set it to a variable and static cast it to an int. E.g. int x = static_case<int>(queue.size()); Let me know if this works.\u00a0"}, {"id": 1616, "value": ""}, {"id": 1617, "value": "Seems like your api.exe was compiled for the wrong CPU architecture. Try recompiling your code inside of CAEN, and ensure that your compile settings are setup properly. See\u00a0https://askubuntu.com/questions/648555/bash-program-cannot-execute-binary-file-exec-format-errorAs a side note: an \"exe\" file is also known as a \"binary,\" since the exe file stores the raw, binary (1s and 0s) machine code to be executed. There's a \"format error\" because the format of said machine code is incorrect for the system's CPU architecture (such as x32, ARM, x86, etc.)."}, {"id": 1618, "value": "Just took a look, you have errors that are preventing your tests from compiling:. . On lines 123 and 195 of your list_tests.cpp, you shouldn't assert_true that it == nullptr. Instead, do ASSERT_TRUE(iter==list.end()) or similar (create an end iterator to compare it to). . "}, {"id": 1619, "value": "RESOLVED: \u00a0I used. freopen(\"test05.in\", \"r\", stdin). instead of the 3 lines above"}, {"id": 1620, "value": "Look at line 183 of your list.h -- I recommend storing your size variable as an integer instead. If T is not an int type this won't work."}, {"id": 1621, "value": "From this image, both of your memory leaks are occurring within your insert function -- I would try checking there to make sure you are deleting any dynamically allocated memory and not attempting to access already deleted iterators."}, {"id": 1622, "value": "Looks like you figured this out -- for other students, the error was defining helper functions and calling them in the tests\u00a0"}, {"id": 1623, "value": ""}, {"id": 1624, "value": "i struggled with this error for so long \ud83d\ude05. there's multiple things that could be causing it, but in my case it was that i was reading in a json when the method was \"GET\", and for that method, you're not supposed to be reading in a json. hope this helps!\u00a0"}, {"id": 1625, "value": "You appear to be applying -- to iter, but iter has been invalidated after you erased the element it pointed to. Doing --iter results in undefined behavior, which may be the issue.\u00a0"}, {"id": 1626, "value": "Well if this all you are writing then you aren't asserting anything about the properties of the lists. Also when you say failing do you mean you are getting and error or are you getting a false positive, or are you not getting any additional points. If it is that you aren't getting any points, then you should be looking if you are actually asserting something. If you are getting an error, you shouldn't because you should be able to set lists equal to each other.\u00a0"}, {"id": 1627, "value": "You can use a for loop to go through four times, and in the body of the function, add ++i.\u00a0"}, {"id": 1628, "value": ""}, {"id": 1629, "value": ""}, {"id": 1630, "value": "Looks like you figured this out -- marking this as resolved. For other students, the error was declaring iterators and not using them in the test case"}, {"id": 1631, "value": "resolved"}, {"id": 1632, "value": "I think a quick fix is that you know what list1.front() should return, so either you could replace and put a 5 or you could store that integer in a variable.\u00a0"}, {"id": 1633, "value": "Well for insert there are a couple cases of where and when you could insert. I think about where I could insert (E.g. front, back...) and once you come up with the different cases, you start to think what do you have to do or what helper functions you can call.\u00a0"}, {"id": 1634, "value": "resolved"}, {"id": 1635, "value": "From the lecture and office hours, I have heard that you can't check for private test cases, but the best way to check leaks is to rigorously test the functions. Also, the biggest way to check leaks is to look through the profs lecture where they tell you if are running into traps when writing functions like pop back, pop front, etc. Additionally, another way to check because macOS does sometimes take care of things that other systems don't you can go and login into CAEN Linux. The Linux system can help you find undefined behavior. Sorry for not helping more, but this is all I could think of. Let me know if you get any other tips.\u00a0"}, {"id": 1636, "value": "From the IAs and office hours, I heard the best way to test these functions is to call them and see what properties that you can observe from the list. For example, if you use the insert function, you can see if the size of the list is supposed to be different or if the front or back datum is supposed to be different. Try using those properties for your asserts. You can do this for erase and other functions.\u00a0"}, {"id": 1637, "value": ""}, {"id": 1638, "value": "I think that could be just an autograder error. My suggestion is to contact the 280 staff or try resubmitting if you can.\u00a0"}, {"id": 1639, "value": ""}, {"id": 1640, "value": ""}, {"id": 1641, "value": "To be completely honest I don't know where that would land you but if you want to find out the best way is to create a list push 3-4 items into the list and point an iterator to the beginning of the list and do the operation. Then you can dereference it and see if it equals of the datum that you think it would be.\u00a0"}, {"id": 1642, "value": "I'm not too sure why my back_1 test case passed on autograder since this is the error message I get:. "}, {"id": 1643, "value": "if you have a json object called object, you add in a key-value pair like this:\u00a0. object[\"key\"] = value;\u00a0. . check out this json tutorial: https://eecs280staff.github.io/p4-web/json.html"}, {"id": 1644, "value": "The decrement operator is needed for the project for some of the functions that deal with iterators, but I tried to do the decrement, and it doesn't work because you violate the requirement's clause. If you need to get to the end, you can point make an iterator that points to the beginning of your list and increment to the last element in your list. This can help you test your functions.\u00a0"}, {"id": 1645, "value": "I had a similar issue. Make sure that when you are running the debugger that you are using in your case Debug and nothing else. Also have a breakpoint, so it doesn't run forever. For some reason my output went straight to my terminal, not to my debug counsel, so the output might be going there for you. Another thing to remember is to do is make api.exe.\u00a0"}, {"id": 1646, "value": "For api, it\u2019s kind of freestyle. For me, I create functions like getapihead and other things in the class and call them in main.\u00a0"}, {"id": 1647, "value": "I would definitely ask an IA or Professor, but from what it seems that you wrote helper functions for your main functions. This doesn't seem like it would hurt your grade because it is a design choice.\u00a0"}, {"id": 1648, "value": "I get this sometimes and instead of racking your brain by looking at your code, I recommend the following:\u00a0. This is a linked list, so it is easy to draw.\u00a0What ever you are trying to test, think about what you want to happen\u00a0. This is where the drawing come in handy. For example, I want to insert this number in between the two elements.\u00a0. Once you know what you want, the behavior to be, look at the functions you are using to achieve the behavior and look at the RMEs and make sure that they are supposed to behave that way.\u00a0After all of this you should know how to set up the environment to test what you want.\u00a0. The biggest problem with tests if that most people look at their own code and write the tests but that could lead to you catering to behavior that isn't intended for the project that you should be catching with the tests. The best way to write tests is to look at the RMEs and see what the behavior is supposed to be with the given input.\u00a0. . I hope this helps. Let me know!\u00a0. "}, {"id": 1649, "value": "solved."}, {"id": 1650, "value": ""}, {"id": 1651, "value": "I think the best way to test it is using your copy constructor. This is where you are going to be using and where implementation really matters. Also you can test two things at once.\u00a0"}, {"id": 1652, "value": ""}, {"id": 1653, "value": "resolved"}, {"id": 1654, "value": ""}, {"id": 1655, "value": ""}, {"id": 1656, "value": "resolved"}, {"id": 1657, "value": "You're supposed to use the standard list in api.cpp."}, {"id": 1658, "value": "the entire thing compiles and runs no problem passing every test case on my IDE but when i submit it on autograder the copy constructor test case has an error."}, {"id": 1659, "value": "If you go to the very bottom of the spec you can find a section saying requirments and restrictions. The libraries that are allowed from the spec are Use these libraries:\u00a0<iostream>,\u00a0<string>,\u00a0<cassert>,\u00a0<sstream>,\u00a0<utility>. In the don't section it says not to use any other libraries than the ones specified.\u00a0"}, {"id": 1660, "value": ""}, {"id": 1661, "value": "If you look at the spec you can see the website by opening the link they give you and from there I think you can interact with the website and look in your terminal to see if you are receiving the requests.\u00a0"}, {"id": 1662, "value": "It looks like you are deleting the same node twice. I'd double-check how you reconnect the nodes after deleting the wanted node."}, {"id": 1663, "value": "yes, there is a space after content-length for every single request output"}, {"id": 1664, "value": "I can't for some reason find the post on piazza, but your output matches what they gave. Hopefully an instructor could repost under this one.\u00a0"}, {"id": 1665, "value": ""}, {"id": 1666, "value": "freopen(\"test05.in\", \"r\", stdin);. . I was having the same issue, and did this ^^ and it started working. I got rid of the assert statement and the other statements it said to use in input redirection"}, {"id": 1667, "value": ""}, {"id": 1668, "value": "You shouldn't add functions then call them in the tests because then they won't compile on AG (since the instructor solution doesn't have the function you'd be calling). Update: the prior information was incorrect, just do ++"}, {"id": 1669, "value": "No. List.end() points to after the last element of a list, so it is a nullptr. You can't erase a nullptr."}, {"id": 1670, "value": "In the lecture, the professor spoke about pop_front and how one could implement it, but that was for a single linked list. The reason where your logic could lead to a problem is when your list has only one element, so you can't set last to last->prev because what would that be (Hint: Draw it out)? I believe that is why it is not letting you do what you are doing. If this were a single-linked list, that may work. You essentially have the cases where you have a list with elements, and you are popping the last one, and then you have a list that is popping its last element. Let me know if this helps or makes any sense.\u00a0"}, {"id": 1671, "value": ""}, {"id": 1672, "value": ""}, {"id": 1673, "value": "Write tests and run your code with address sanitizers (tutorial)"}, {"id": 1674, "value": "From the professor and IAs they suggested that you use copy_all in the copy constructor and the list = operator. If you test those functions, then you can test the copy_all functions. I don't think that I can tell you how to test. I can give you the hint that copy constructors means the list should have the same properties. This should give you some things to compare.\u00a0"}, {"id": 1675, "value": "You have the following error: calling the private constructor for Iterator in your tests. I looked through your test file and it looks like you do this multiple times (not just line 182) so be careful.. . Your test does:. List<int>::Iterator it2 = List<int>::Iterator(it);. . Instead, you should do:. List<int>::Iterator it2 = it;. As it is already an iterator.. . Does that make sense? You should only declare iterators like this:. List<int>::Iterator it = list.begin(); or List<int>::Iterator it = list.end();. . . "}, {"id": 1676, "value": "Here's the error: you have unused iterators in your tests. Make sure you are compiling with the make command given in the makefile & sanitizer flags. Here's the command to compile it if you want to just copy paste the command:. . g++ --std=c++11 -Wall -Werror -pedantic -g -Wno-sign-compare -Wno-comment List_tests.cpp -o List_validity_check.exe. "}, {"id": 1677, "value": "This just means that the json object that is attached to the \"results\" key does not contain any elements, hence why the count is 0 as well."}, {"id": 1678, "value": "the standard library list does not implement `operator[]`, so you should use iterators instead.. . If you're curious, recall that we learned indexing is a combination of pointer arithmetic and dereference. This gives you a hint as to why linked lists do not implement `operator[]`."}, {"id": 1679, "value": ""}, {"id": 1680, "value": ""}, {"id": 1681, "value": ""}, {"id": 1682, "value": ""}, {"id": 1683, "value": "It should be okay to just use ints, because the tests are more to test the functionality of doing different operations on the list rather than the difference between different types of variables. I don't think using different variable types would necessarily catch more bugs.\u00a0"}, {"id": 1684, "value": ""}, {"id": 1685, "value": ""}, {"id": 1686, "value": "you can check on your launch.json file, your args might be. . \"args\": [\"\"],. . , delete the \"\", and make args to. . \"args\": [],. . , just blank in [ ]is ok."}, {"id": 1687, "value": "Your iterator should continue pointing to 2 after insert() runs. :)"}, {"id": 1688, "value": "Yes. Per https://eecs280staff.github.io/p4-web/#error-handling, you may assume that \"Requests are properly formatted\"."}, {"id": 1689, "value": "solved"}, {"id": 1690, "value": "You are correct that the error is because you are returning by reference. Consider the logic here: if you return a value by reference from a function, then it should be a value that will continue existing after the end of the function call. `begin()` and `end()` both create and return an iterator, so if you return by reference it will return the object in that function call's stack frame instead of something that continues living after the end of the function call.. . So it would be incorrect to return by reference in `begin()` and `end()` -- you want to return by value so that you can access and use a different object in the caller function's stack frame."}, {"id": 1691, "value": ""}, {"id": 1692, "value": "Your first interpretation is correct, you want to compare the pointers they hold and check whether or not they are equal. This is accomplished by comparing node_ptr to rhs.node_ptr, so the implementation would contain the following comparison: [node_ptr == rhs.node_ptr]. The function would return the outcome of this comparison.. . If your implementation is still showing bugs, please come to office hours!\u00a0"}, {"id": 1693, "value": "Resolved"}, {"id": 1694, "value": "\"heap-use-after-free\" means you are probably trying to use a dynamically allocated object after it has been freed. previously allocated by is saying where the object was created, freed by thread is saying where it was deleted"}, {"id": 1695, "value": "The auto keyword has worked for me but I don't think you need to use iterators for those functions, as iterators are used to interact with the class from outside. In professor DeOrio's lecture on linked lists he has similar code for a forward list that is very helpful to reference for the clear and copy functions."}, {"id": 1696, "value": "marking resolved"}, {"id": 1697, "value": "no, think about the difference between the assignment operator vs. copy constructor"}, {"id": 1698, "value": "Cout the exact output specified for the project in the error handling section. from the user point of view they would get this:. . HTTP/1.1 400 Bad RequestContent-Type: application/json; charset=utf-8Content-Length: 0. "}, {"id": 1699, "value": "Double check your push_front, you might be trying to treat a nullptr like it points to something. Try and think about edge cases for pushing to a list."}, {"id": 1700, "value": ""}, {"id": 1701, "value": "When including your own code in your question, please mark the question as private! In terms of your error, how does your function handle when the list has one element already, or is empty?"}, {"id": 1702, "value": ""}, {"id": 1703, "value": "I found it easier to not have a position variable as there is only one section where you need a position other than position one. Think of how you can add their position in the loop when making the queue vector of students.\u00a0"}, {"id": 1704, "value": "the second one"}, {"id": 1705, "value": ""}, {"id": 1706, "value": "It's looking for a function names 'construct_at' but can't find one. Make sure the function is declared/defined within the file where you are calling it, or #include the file where it lives. Also make sure you're passing the function the right type/number of parameters."}, {"id": 1707, "value": "I would check where in push back you assign nodes to be null, then consider when that line is executing and when you want it to be executing."}, {"id": 1708, "value": ""}, {"id": 1709, "value": ""}, {"id": 1710, "value": ""}, {"id": 1711, "value": "Try testing how functions would work with an empty/close to empty/ not empty list"}, {"id": 1712, "value": "It looks like you are trying to dereference a null pointer. . Run your code through CAEN, it will run it through a similar environment to the autograder and you can debug that way. Just make sure to turn off address sanitizer"}, {"id": 1713, "value": ""}, {"id": 1714, "value": ""}, {"id": 1715, "value": "Writing test cases can help you determine if your functions are working! We can help with more specific questions"}, {"id": 1716, "value": ""}, {"id": 1717, "value": "the only valid ones are the 5 in the spec"}, {"id": 1718, "value": ""}, {"id": 1719, "value": "Hi! Please add your uniqname to your username and we'll check out your autograder submissions!\u00a0"}, {"id": 1720, "value": "An iterator is not a pointer so you may not say some iterator is nullptr. But end does gives you an iterator that \"pass the end\", and if you think about your implementation, what lives inside its node pointer is a nullptr. There is not prev or next for a nullptr, and there is no way that you may go back using --."}, {"id": 1721, "value": "201 Created is for the post request and 200 OK is for all the get requests.\u00a0"}, {"id": 1722, "value": "You may not get the node pointer directly as it is in the private scope. list.begin() gives you an iterator that points to the first element in the list. You can move the iterator around to get other elements in the list."}, {"id": 1723, "value": "It depends on the fctns. For example, if you create those node in insert or both of the push fctns, you want to be able to use those elements added to your list later, so you shouldn't probably deleted it. These new added node will be deleted by destructor if implemented correctly. But for any other functions, where these new Nodes created are not needed after the execution of the fctns i.e. it is not inserted inside the list, you should probably delete it"}, {"id": 1724, "value": "Delete must be combined with /api/queue/head/ for a successful delete head request. Otherwise, it is considered as a bad request."}, {"id": 1725, "value": "Likely something went wrong with your insert function. Please double check that the function implementation matches the declarations (for example, same parameters, same return type) and the return type is good."}, {"id": 1726, "value": "We do not have == nor != for two lists, so if you use ASSERT_EQUAL(list1, list2), it won't work. You may compare the elements in the list one by one using loops."}, {"id": 1727, "value": ". string str = \"hi\";. . str == \"hi\" // is true. str == \"hai\" // is false"}, {"id": 1728, "value": "Hint: you have functions that can add and remove stuff from your list which (assuming you implemented correctly) works for all cases even when the list is empty, why not use them? (pop,push,...)"}, {"id": 1729, "value": "Did you\u00a0make List_tests.exe first?"}, {"id": 1730, "value": "yes (you need 2 newlines)"}, {"id": 1731, "value": "when you cout the json object, it'll alphabetize by key, so yes, that's supposed to happen"}, {"id": 1732, "value": "Resolved"}, {"id": 1733, "value": "I am having the same issue, every time I try to compile/run it fails on the cin >> body and brings me to the computer memory page"}, {"id": 1734, "value": ""}, {"id": 1735, "value": ". template<typename T>. void List<T>::erase(Iterator i). . The\u00a0List<T>:: indicates that the\u00a0erase method belongs to the\u00a0List<T> class"}, {"id": 1736, "value": "pop_back is expected to do this. Your function is likely wrong."}, {"id": 1737, "value": "Yes, it would be a good idea to write test cases for those!"}, {"id": 1738, "value": ""}, {"id": 1739, "value": "yes"}, {"id": 1740, "value": "resolved"}, {"id": 1741, "value": "GET /api/ always returns the same thing so it doesn't matter if the queue is empty. . POST request adds to the queue, should work even when the queue is empty"}, {"id": 1742, "value": ""}, {"id": 1743, "value": ""}, {"id": 1744, "value": "Weird, heres some ideas I can think of:. . - do you have a loop? it could be an infinite loop. - do you ever cin in that test?. . Try printing \"hi\" between every line and see how many times it prints. Or use a debugger"}, {"id": 1745, "value": "I had this same error if you read in the json body and are trying to access \"uniquename\" its \"uniqname\" Im guessing it says something along the lines of its a null if its the same issue I had. Took me hours to realize this and thought it was an error with how I read in json as well."}, {"id": 1746, "value": "I would check functions that return the datum, like front, back, and dereference operator, to make sure you're not returning an int (instead return T).\u00a0"}, {"id": 1747, "value": "list.begin() returns an iterator to the beginning of the list. Then just use\u00a0++ to get to the element you want."}, {"id": 1748, "value": ""}, {"id": 1749, "value": "It sounds like you've got the general idea for copy_all() correct. It sounds like your issue is likely with the loop condition or your push_back() implementation. You should try testing your push_back() function to see if that is the issue. If it is not, you can try using the debugger to set breakpoints before you have the problem and then step through to see what's going on.. . EDIT: In your assignment operator or copy ctor, you should also clear you list of its original data before copying new data"}, {"id": 1750, "value": ""}, {"id": 1751, "value": ""}, {"id": 1752, "value": "You need two newlines after printing content length"}, {"id": 1753, "value": "A memory leak usually means that you've created memory on the heap but not deleted it. It makes sense this is exposed by your test cases, since that is when your code is actually being run. A compiler generally won't find when you have code that causes a memory leak. You should read over the address sanitizer message and/or use the debugger to find which function or part of your code caused the error and that will narrow things down so you can fix it more easily."}, {"id": 1754, "value": "Figured it out - just have to include the following arg in launch.json:. . \"args\": [\"<\", \"test01.in\"],. "}, {"id": 1755, "value": "\"heap-use-after-free\" means you are probably trying to use a deleted object. So you delete at some point, but then still try and access that same node.\u00a0"}, {"id": 1756, "value": ""}, {"id": 1757, "value": "make ur own. . hint, copy paste just the \"delete queue head\" part for the .in, and the output, copy the \"400 bad request\" for the .out.correct, u can find them in the other test files, and u can manually run the test:. . . . ./api.exe < test06.in > test06.out. . . . You can do the same thing for get /api/queue/head"}, {"id": 1758, "value": "I don't remember the syntax, (it should be in lecture slide or somewhere), but note that insert and erase is of the\u00a0List class, not\u00a0 Iterator class.\u00a0"}, {"id": 1759, "value": ""}, {"id": 1760, "value": ""}, {"id": 1761, "value": "make sure when u do cin >> in main you are putting all the header stuff into a string and reading the body into a json because the format you're given for tests isn't automatically in json format"}, {"id": 1762, "value": ""}, {"id": 1763, "value": ""}, {"id": 1764, "value": ""}, {"id": 1765, "value": "Yes, test iterators"}, {"id": 1766, "value": "This may sound generic, but from what I am seeing, you are leaking memory in your insert and push_back functions. This is a common problem because this is where you are allocating new memory. I would make sure your list destructor is deleting everything properly. Also, I don't exactly remember what lecture this is, but the Profs do go over potential memory leaks that everyone gets with dynamic memory. There are like 6 types. I would take a look at the slide and make sure you are following the protocol given.\u00a0"}, {"id": 1767, "value": "@3477"}, {"id": 1768, "value": ""}, {"id": 1769, "value": "You should use list from the standard library in your api.cpp not List.h you implemented."}, {"id": 1770, "value": "yes that would be like inserting to the end of the list"}, {"id": 1771, "value": ""}, {"id": 1772, "value": "Everything inside curly braces shown in the spec should be formatted as JSON, i.e., count and results are also part of JSON, not regular cout."}, {"id": 1773, "value": ""}, {"id": 1774, "value": "Iterator is a class outside of class List, so if you want to call a non-static member function of List, you need to instantiate a List class and call the function on that instance. i.e.,\u00a0. List l;. l.clear(). In this case, however, think about whether you need a destructor for Iterator in the first place. Iterator is an external data structure that points to dynamically allocated objects in List, which means itself does not allocate dynamic objects."}, {"id": 1775, "value": "resolved"}, {"id": 1776, "value": "a for loop works well, just make sure you're using an iterator object in the for loop. As well, /api/queue requires the output to be its own json file, so make sure you aren't outputting directly out of the loop and are instead using it to add to an output json file, then print out that."}, {"id": 1777, "value": ""}, {"id": 1778, "value": "I would try to simplify this function by using some of the other functions that you have already implemented. For instance, using the structure of \"if the iterator is pointing to the first node, call pop_front, if it's the last, call pop_back, otherwise it's in the middle and we need to do something else\" is a popular choice among other students."}, {"id": 1779, "value": "It looks like in your pop_front, you are creating another piece of dynamic memory to hold your \"victim\" node in. However, remember that when you pushed this victim node into your list originally, you also created dynamic memory for it there. So, you basically have two piece of dynamic memory now, and are only deleting one. Try fixing this by changing the lines where you create dynamic memory in this function to just . . ```. Node * n = first. ```. . That way you are just assigning the first node to a temp node and then when you call `delete n` it will delete the original piece of dynamic memory created for that first node."}, {"id": 1780, "value": "If it works it works I guess. Although you probably want to write your own private tests because the public tests don't cover everything"}, {"id": 1781, "value": "Resolved. For other students, if you have a list that is holding your Student objects, look at some online resources for how to use iterators to loop through a std::list."}, {"id": 1782, "value": "change int to T and remove const:. . . \u00a0 //REQUIRES: list is not empty. \u00a0 //EFFECTS: Returns the first element in the list by reference. \u00a0 T & front() {. \u00a0 \u00a0 assert(!empty());. \u00a0 \u00a0 return first->datum;. \u00a0 }. . that's what I have"}, {"id": 1783, "value": "you can do this:. . i = begin();. . instead of i = first bc i is an iterator not a pointer"}, {"id": 1784, "value": "You made the operator++ function const, meaning that all objects in the function will be read-only. This is what the error is telling you, as you are trying to change the value of node_ptr (as you should). Think about whether making this function const or not makes sense in the context of what the ++ operator is supposed to do."}, {"id": 1785, "value": "You can use end() to create an iterator, but because it's just a nullptr you won't be able to increment it or decrement it in the same way that you would for .begin() (dereferencing a nullptr is a segfault)."}, {"id": 1786, "value": ""}, {"id": 1787, "value": ""}, {"id": 1788, "value": "Remember that you only need the big 3 in any class that is creating dynamic memory. Think about whether you are creating dynamic memory in the iterator class or not."}, {"id": 1789, "value": "I assume that you are talking about the == operator for iterator, and with that in mind remember that this operator is checking to see if the two iterators it is compare are pointing to the same node (not just two nodes that have the same value in them). So, something like . . `list.begin() == list.begin()`. . should return true."}, {"id": 1790, "value": "resolved"}, {"id": 1791, "value": "The question of whether you should store position as a member variable in the Student struct is an interesting design question. Let's consider the pros and cons.. . Pros of including position in Student struct:. - easier to access position of a given student when you need it (ie. student.position). . Cons of including position in Student struct:. - must update the position of every student on the queue whenever someone is popped off the front. . Updating the position of every student on the queue whenever someone is popped off the front sounds like a lot of work. The question then becomes: is it possible to infer the position of a student on the queue without storing position as a member variable?. . You mention a good idea:. . \u00a0I imagine there is a function I should write that iterates though my queue and returns the position, but I don't know how to go about doing that.\u00a0. . A queue is a std::list object, and we know that we can use an iterator to iterator through a std::list. We also know that a std::list guarantees that our students remain in order, so if we iterate from queue.begin() to queue.end(), we know that the first student we see has position 1, second has position 2, etc.. . A google search for \"cpp iterating through a list using iterators\" showed me this StackOverflow link: https://stackoverflow.com/questions/22269435/how-to-iterate-through-a-list-of-objects-in-c"}, {"id": 1792, "value": "Apologies, but we cannot give this kind of specific guidance regarding test cases.. . In general, take a read through the error handling portion of the spec and try to form all kinds of \"weird\" input that violate 1 (or a combination) of the errors listed on the spec.. . Sorry that we cannot give more specific help."}, {"id": 1793, "value": "It doesn't look like your list_tests are compiling. You are calling `.copy()` and `.end_list()` in your tests which aren't functions that exist."}, {"id": 1794, "value": "In general, doing. . student.location = js_in[\"location\"];. should work, assuming that there exists a json object called js_in with a field called \"location\".. . Double check to make sure that you have constructed the json object properly, maybe try printing it out to make sure it looks like what you expect it to look like.. . Other than this, it is hard to give you more guidance without looking at your code, so possibly a question for office hours."}, {"id": 1795, "value": "The code you show above seems like perfectly fine code for constructing a json object (assuming you included json.hpp and did using namespace nlohmann::json, which you said you did).. . If you tried this on Lobster, this would fail because it relies on there being a file called \"json.hpp\" in the same directory that implements the json class. Lobster does not have this by default, but the starter files for project 4 include an actual file called \"json.hpp\" that does this. Trying running the same code in your api.cpp in your project directory - it should work!"}, {"id": 1796, "value": "Similar error: @3476. . In general, try to track down (using the debugger) to see where you may be trying to read in a json object when there is no json to read in the input."}, {"id": 1797, "value": "Return 0 should happen when you are unable to read in *any* api endpoint and method (there's either 0 strings to read in or only 1 string to read in). This essentially means that the user is done making api requests, so we can safely return 0 and end the program.. . If you are able to read in an api endpoint and method, then you should error check this input to see if it is valid. If not, print out the response specified in the spec and keep reading in more endpoints."}, {"id": 1798, "value": "From prof DeOrio's lecture 6:. . . I think it has something to do with the file continuing to read in information despite there being no more content to read in. The current condition to continue reading in information is while(!cin.eof()){}; however, this continues to read in one more time after the input file has finished giving requests.. . I think you are spot on! Consider how you can use the >> operator instead of !cin.eof() in your while condition to make sure you don't make an extra read when the input file has nothing left."}, {"id": 1799, "value": "This means that the autograder is running your custom tests on your implementation and the tests are failing. Right now, you are also failing the list public test so I would try to focus on fixing that error first (check to make sure that your default constructor is setting up the first and last variables correctly!)"}, {"id": 1800, "value": "To prepare for the next request. You throw a bad request error but you don\u2019t exit the program. There might be more requests that come after that. If that happens, you need to get rid of the excess stuff thats currently in the stdin buffer.\u00a0. . And yes, the program should continue reading in requests"}, {"id": 1801, "value": "I had the same issue when I was doing erase(). It's possible that the next and prev nodes of the new node you're creating aren't being properly linked together, or that the edge cases for erasing the beginning/end nodes aren't being accounted for"}, {"id": 1802, "value": ". 1. For the GET /api/queue/ \u00a0function, how do we print out the json array that have the indentation. Right now it prints out the json array that starts with [ instead of {, I wonder how can we make the json array into a single json, or print with indentation.. . 2 things here: indentation and \"json array that starts with [ instead of {\". For the \"json array that starts with [ instead of {\", you will notice in the correct output that the json array actually does start with '[', so that is fine.. For the indentation, an idea is to to have 1 json object for the entire response, and 1 json object/array for the students on the queue. Then you can do something like. . response_json[\"results\"] = queue_json;. then simply print out the response_json at the end. This will ensure the indentations are formatted properly.. . . 2. Also for the content length, it's seems that it's not an addition of all the content-length of the json in the json array. I understand the length represents the byte length, but in this case, I wonder how can we compute it.. . My guess is that the Content-Length currently being printed is wrong because it is not account for the additional spaces for indentations. Using the method described above to create a \"wrapper response json\", then using the \"dump+length\" method described in the spec should ensure you get the correct Content-Length"}, {"id": 1803, "value": "Your destructor is declared as private, which is a problem because that means that no outside file will be able to call it. The destructor is similar to the constructor as it should probably always be public to ensure that other files are able to create and destroy the object as needed."}, {"id": 1804, "value": "The same thing happened to me; it is a memory allocation issue. I fixed it by removing unnecessary semicolons at the end of my default constructors.\u00a0"}, {"id": 1805, "value": "This is because your list_tests.cpp file isn't compiling. On line 182 you are asserting that \"it\" and nullptr are equal. While this logically makes sense, the way that ASSERT_EQUALS is implemented doesn't allow this. You can check to see if your list_tests file compiles by trying to compile it in the Autograder."}, {"id": 1806, "value": "From the AG submit, lines 69-70 in List_tests is quite fishy and may be causing an issue.. . First, conceptually, if you make an iterator to .end(), then increment that iterator, this violates the requires clause of the ++ operator. I think this is causing an assertion to fail.. . Second, the syntax for incrementing an iterator should be ++it (where it is an iterator object).. . Honestly unsure why there is no output on your end though. Possibly something to check on office hours if you continue to get no output."}, {"id": 1807, "value": "Are you running. . make List_tests.exe. ./List_tests.exe. from your terminal?. . In general, this is difficult to debug without more context on you code, your IDE, your directory structure, and how you are compiling. Apologies but this question may be better suited for office hours."}, {"id": 1808, "value": "From this StackOverflow post, it seems like a bad access error is given when you are trying to access an object that no longer exists.. In your case, since you are crashing on \"last->next = nullptr;\", it's possible that the Node pointed to by \"last\" had been deleted somewhere else before we got to this line.. . Double check your implementation of the Big Three, and use the debugger to step through the lines on the test case you are failing, making sure at each step that your List is behaving as you expect it to."}, {"id": 1809, "value": "yea, you can just cin a bunch of dummy stuff.. . Everything is useless except like \"GET\" (the method), \"api/queue/head\" (the path), probably the content length, and the json itself."}, {"id": 1810, "value": "Got no solution for ya, but we're havin the same issue."}, {"id": 1811, "value": ". Every request has the same format. The only parts that change are the method (GET\u00a0in this example), the path (/api/\u00a0in this example), the content length (0\u00a0here) and the body (empty here).. . Assume its always\u00a0localhost"}, {"id": 1812, "value": ""}, {"id": 1813, "value": "yes"}, {"id": 1814, "value": "I was getting the same problem, were you able to solve this?\u00a0"}, {"id": 1815, "value": "Convert the `json` object to a string, then get the length of the string."}, {"id": 1816, "value": ""}, {"id": 1817, "value": "resolved"}, {"id": 1818, "value": "what is the line u are running. also, try scrolling up with the scrollbar on the right."}, {"id": 1819, "value": ""}, {"id": 1820, "value": ""}, {"id": 1821, "value": ""}, {"id": 1822, "value": "I would suggest looking at the section of the \"Working with JSON\" page from the spec about JSON arrays.\u00a0. "}, {"id": 1823, "value": "@2965. . Check what the error is and fix it"}, {"id": 1824, "value": "okay sorry, for some reason my computer was acting up, I suggest looking at post @3215, you can just create another json so you can add(pushback) another student to the list."}, {"id": 1825, "value": "same question. I'm having trouble making a copy constructor and destuctor for Iterator. Do we need a nondefault constructor too?"}, {"id": 1826, "value": "You can use cin as the condition, because it will end the loop once there's nothing left to read. For example:\u00a0. . str s;. while (cin >> s) {. /*...*/. }. would read in until there are no more strings to read in."}, {"id": 1827, "value": ""}, {"id": 1828, "value": "We just implement list for practice. Using list.h in api is discouraged."}, {"id": 1829, "value": ""}, {"id": 1830, "value": ""}, {"id": 1831, "value": ""}, {"id": 1832, "value": ""}, {"id": 1833, "value": "solved."}, {"id": 1834, "value": "I have the same question! Help with why this is causing a segmentation fault would be greatly appreciated."}, {"id": 1835, "value": "You could either remove the parentheses or replace them with curly braces to call the default constructor."}, {"id": 1836, "value": "You are accidentally using\u00a0List<int>\u00a0instead of\u00a0List<T>\u00a0in part of your code."}, {"id": 1837, "value": "be sure you put all of the operators in the public part of the iterator class"}, {"id": 1838, "value": "Running a leak checking program would give you more specific guidance on where leaks occurred and how you could fix them. https://eecs280staff.github.io/tutorials/setup_leakcheck.html. In general, every new in your program should be paired with a delete when the object is no longer needed."}, {"id": 1839, "value": "I would just use `List` for simplicity. With `double`s, you will need to account for floating-point precision which can be a bit of a hassle to work with in tests. I don't think there's really a reason you would need to use any other types besides `int` in your list tests."}, {"id": 1840, "value": "There are two newlines at the end of the HTTP headers, before the requests body (if present) begins. You can use this as a sort of sentinel to determine when the headers have ended."}, {"id": 1841, "value": "It looks like you haven't implemented the `operator*` overload for the `Iterator` class, or you haven't implemented it properly. It should return a `T &` type."}, {"id": 1842, "value": "In general, you should start off by writing at least one test case for _each_ function in your source file.  In each test, consider if there are any edge cases, and make sure you understand what the spec/RME says the function should be able to handle.  For example, back in project 2, when we were dealing a lot with `Matrix` tests, an example of an edge case you should have accounted for there would be, say, a 1x1 `Matrix`.. . With that in mind, try going through each of your `List` class methods (and `Iterator` methods) and writing a \"normal\" use-case test for it, and then writing any edge-case tests you come up with additionally.  In general, it's good to check that functions that _modify_ something actually _do_ modify it in the way expected, and that functions that _return_ something actually _do_ return what they are supposed to.  This should give you a good starting point; if you need more help, you might consider going to office hours."}, {"id": 1843, "value": "In general, the body of a GET request will usually be empty, however, it does not ***have*** to be.  As in this test case, you should, in this project at least, **always** use the HTTP header information (`Content-Length`) to determine how many more characters there are in the body, since the HTTP headers are guaranteed to be correct in this project."}, {"id": 1844, "value": ""}, {"id": 1845, "value": "Run your code through CAEN, it'll run it in a similar environment as the autograder. Make sure you turn off address sanitizer cause CAEN doesn't work with it."}, {"id": 1846, "value": "You should open the file and read in the file input and output the content type, content length etc.\u00a0"}, {"id": 1847, "value": "resolved in followups, i think"}, {"id": 1848, "value": "You don't have to tests different data types. A thorough testing suite with all ints, or all doubles, should expose any bugs.\u00a0"}, {"id": 1849, "value": ""}, {"id": 1850, "value": "Nodes that are dynamically allocated when insert is called should be deleted in pop_front/pop_back/erase/ or the list deconstructor. You don't have to keep track of which nodes were added from push front or push back vs those that were added from insert. They are the same to the list, and should be deleted in the same ways."}, {"id": 1851, "value": ""}, {"id": 1852, "value": "This is a nitpicky C++ warning from the compiler flags: it means that the order you are initializing your member variables in the constructor is not the same order that they are defined in the private section as member variables. Make sure that if you are initializing them in the order of first, last, size then they are declared in private as:. . node * first;. node * last;. int size;"}, {"id": 1853, "value": "Yes, if you're inserting to the back of a list you have another function that you could call to help."}, {"id": 1854, "value": "You don't need to save anything; the queue is just temporal (only kept in-memory while the program runs) in our case. In a real server, you would definitely persist it to a file or database table, but that's beyond the scope of this project."}, {"id": 1855, "value": ""}, {"id": 1856, "value": ""}, {"id": 1857, "value": "Resolved"}, {"id": 1858, "value": "It seems like you haven't implemented the operators yet."}, {"id": 1859, "value": "Make sure that you are never assuming that the List contains a specific data type such as int, and instead always use T as the data type of the elements within the container. Common areas where this may happen are dereference operators, copy constructors, front, and back."}, {"id": 1860, "value": "iirc, that the error means that you're trying to clear up the same spot in memory twice. based on a google search, if you run into that error, you most likely are using an invalid pointer (ie. pointer is not properly initialized, or pointer doesn't point to a valid address in memory, etc.)\u00a0. . also, check this answer: @3351"}, {"id": 1861, "value": "This error means that you are attempting to use a dynamically allocated object after it has been deleted. I would start by double checking your implementations for pop_front() and pop_back() considering the edge cases of popping."}, {"id": 1862, "value": "I have the same question as I am a bit stuck on this\u00a0"}, {"id": 1863, "value": "This test does not work on Vscode because the compiler does not allow it. If you would like to test self-assignment, try making a pointer to the list, and checking to see if  the assignment operator works correctly when you run `list = *ptr;`."}, {"id": 1864, "value": "try the followup @3407_f2"}, {"id": 1865, "value": "Yes, that is correct."}, {"id": 1866, "value": "I would double check your Iterator dereference operator with respect to templating."}, {"id": 1867, "value": ""}, {"id": 1868, "value": "Generally, I don't think we have such function :( You probably just need to loop through everything.. But in your List_test.cpp, you can just create an iterator to the last element using ++ multiple times. At least that is how I do it"}, {"id": 1869, "value": "I don't think we need to test -- operator because it is already given inside the starter file.. But for pre-increment operator(++), you can try using it on any iterator that you create and try dereferencing it to make sure it returns the expected new datum rather than old datum."}, {"id": 1870, "value": ""}, {"id": 1871, "value": "I believe it should be able to run if your code is correct. Have you tried running it through AddressSanitizer.. If you have done so, have you changed any code inside the original List_compile_check.cpp? I have a similar problem and it turned out that the problem was I made a change to the List_compile_check.cpp (while debugging) that makes the .cpp file invalid. It is highly unlikely but if you have modified List_compile_check.cpp before, better check if you made any significant changes."}, {"id": 1872, "value": "Instead of using fstreams, you should just cin and cout with input/output redirection to read from the test files and write to files."}, {"id": 1873, "value": ""}, {"id": 1874, "value": "I don't know if that's the reason for the autograder test fails, but yes, you would want to use ASSERT_TRUE, ASSERT_EQUALS, etc."}, {"id": 1875, "value": ""}, {"id": 1876, "value": "That\u2019s weird. This seems like a good question for office hours."}, {"id": 1877, "value": ""}, {"id": 1878, "value": ""}, {"id": 1879, "value": ""}, {"id": 1880, "value": ""}, {"id": 1881, "value": "When you default initialized a list, it should be empty. So, you should also initialize last with nullptr.\u00a0"}, {"id": 1882, "value": ""}, {"id": 1883, "value": ""}, {"id": 1884, "value": "You can sync your files to caen and use valgrind to check. 1. ssh <your-uniqname>@login.engin.umich.edu. 2. cd to your project file and run make sync2caen. 3. go to caen, find your file, make debug executable. 4. Run valgrind ./execution_debug"}, {"id": 1885, "value": ""}, {"id": 1886, "value": ""}, {"id": 1887, "value": "Resolved"}, {"id": 1888, "value": ""}, {"id": 1889, "value": ""}, {"id": 1890, "value": "I believe we should just use pre-increment when we want to add to the pointer."}, {"id": 1891, "value": "solved"}, {"id": 1892, "value": "yes, also 400 is for bad request"}, {"id": 1893, "value": ""}, {"id": 1894, "value": ""}, {"id": 1895, "value": ""}, {"id": 1896, "value": ""}, {"id": 1897, "value": ""}, {"id": 1898, "value": ""}, {"id": 1899, "value": ""}, {"id": 1900, "value": "nullptr\u00a0should work"}, {"id": 1901, "value": "You want to write as much as you can in your class to avoid having a long function penalty for main. Overall, you might want to keep it as modular as possible"}, {"id": 1902, "value": "Yes, and when you use it is mostly up to you. You make an iterator object directly like this:. . List<T>::Iterator it = your_list.begin();. . . Remember T is a template.\u00a0"}, {"id": 1903, "value": "Does it work if you increment i before erasing?. . if so, it is possible that you have a problem in an edge case where i is the first element and likely if I is the last.. . That is what happened to me, and i just used an if statement to check if it is the first element and just pop_front() or pop_back() if i is the last element.. hopefully this helps. "}, {"id": 1904, "value": "resolved"}, {"id": 1905, "value": "Yes you typically need all memebers of the big three if you use one of them"}, {"id": 1906, "value": "Make test cases for front/back. While your pop functions might use these functions the buggy code used for testing is likely different, and therefore any bugs that might be in regards to the front/back functions wouldn't be caught.. This is why we always want to write test cases for everything. You're getting points for how good your tests are at catching bugs, not how exactly your code is written."}, {"id": 1907, "value": ""}, {"id": 1908, "value": "It is supposed to be false right? The line \u00a0cout << b << endl; after it should output 0, implying that statement is false."}, {"id": 1909, "value": "For the == overload function, you don't need Iterator. bool operator== is fine."}, {"id": 1910, "value": "I had this exact same issue with only those two failing to compile. I added \"const\" right before the brackets of my overloaded assignment operator declarations for == and != and that seems to have solved the issue."}, {"id": 1911, "value": ""}, {"id": 1912, "value": "I had this error originally and I recommend adding an if statement to check if the list is empty because if it is you don\u2019t need to access last or first next and prev"}, {"id": 1913, "value": "Resolved. "}, {"id": 1914, "value": ""}, {"id": 1915, "value": "yes, in list_tests.cpp\u00a0"}, {"id": 1916, "value": ""}, {"id": 1917, "value": "Line 5 appears in the correct output because that is the next line text would be inserted on.\u00a0 What the spec means by \"extra line\" is that there should be a blank line between outputs which actually requires cout-ing two endlines."}, {"id": 1918, "value": ""}, {"id": 1919, "value": "I believe it is a double free error, which means you are trying to delete an already deleted object in heap. Make sure you only delete all the dynamically allocated object once in your code (usually in List class destructor).. "}, {"id": 1920, "value": "Looks like you're not properly `delete`-ing your nodes in your `pop_front` method"}, {"id": 1921, "value": ""}, {"id": 1922, "value": "All of them :)"}, {"id": 1923, "value": "nevermind, fixed it the issue! :)"}, {"id": 1924, "value": "From the spec, you are given some guarantees about when there is a json body. If you go to the \"you don't need to handle these errors\" part of the error handling section, you will find:. . Content-Length of a request is correctAll GET and DELETE requests will have a Content-Length: 0If Content-Length: 0, there will be no JSON body. Consider how you can use these guarantees to check for when to read in a json body."}, {"id": 1925, "value": "Assuming you are talking about the Canvas announcement that went out about the autograder reconfiguration, you do not have to change anything about your starter files or test cases."}, {"id": 1926, "value": ". what does deleting the item actually mean?. . Deleting a node means that we reconfigure our list to not include it, and deallocate its memory on the heap.. . . I do not know how to handle these functions when there is only one node in the list. Do I set first and last to nullptr?. . Yes. . . what do I do to datum?. . Since you are deleting a node, you do not need to change the datum of anything.. "}, {"id": 1927, "value": "Assuming you are talking about line 61 of compile_check, at this point:. - my_list is a list of 2 nodes: 42, 42. - iter is an iterator pointing to the second 42. . So when we do ++--iter, we are:. - moving iter to the first 42. - then moving iter back to the second 42. . . . node_ptr apparently does not have a prev node so when -- sets the ptr to nullptr, the next step, ++, fails the assert statement. . . If you find that the first -- is setting node_ptr to nullptr, then something may be going wrong before this step in the code."}, {"id": 1928, "value": "@3324"}, {"id": 1929, "value": "Using code from List_compile_check.cpp in your List_tests.cpp would not violate the honor code.. . I don't think you will catch many interesting test cases with just List_compile_check though."}, {"id": 1930, "value": "One way to do this is described by the hint above your size function: you can create a private member variable to keep track of the list's size. This private variable can be modified and used by push_back"}, {"id": 1931, "value": ". I have a json array with json objects of the students on the queue. . . You are correct - we have an array of json objects, so we can just index as we usually would.. . Using the example from the spec:. . json output;. . json j4 = {. \u00a0 {\"happy\", true},. \u00a0 {\"pi\", 3.141}. };. output.push_back(j4);. . json j5 = {. \u00a0 {\"happy\", true},. \u00a0 {\"pi\", 3.14159265359}. };. output.push_back(j5);. . Then. . cout << output[0] << endl;. would print. . {. \u00a0 {\"happy\", true},. \u00a0 {\"pi\", 3.141}. }. . ---------. I will note, though, that I am unsure if you would ever need to do this in the project. If you just wanted to first student from the OHQueue, do you need to add all the students into a json object then take the first student, or is there a simpler way to do this?"}, {"id": 1932, "value": ""}, {"id": 1933, "value": "Yes, you will delete the node that the iterator is pointing too. Incrementing your iterator after the deletion is unnecessary, however."}, {"id": 1934, "value": "When you use `ASSERT_EQUAL` in the unit test framework, the `first` and `second` in `ASSERT_EQUAL(first, second)` needs to be comparable using the `==` operator. You were comparing a string to an iterator, which can't be compared. To resolve the error, you might want to directly compare two iterators or two strings."}, {"id": 1935, "value": "It looks like you are using a postincrement in your test cases, whereas we only defined a prefix increment in List.h. . Changing instances of. . iterator++. to. . ++iterator. should fix this!"}, {"id": 1936, "value": "As long as your white spacing matches that of the public tests, you\u2019ll be fine for the private tests.\u00a0"}, {"id": 1937, "value": "This may be hard to debug without the additional context of your code, so it seems like a good question for office hours.. . In general, a common case for segfault in this project is if you try to dereference a nullptr. Check through your methods to see if you are handling edge cases (like when the list is empty, or if there was only 1 element, etc.). Another tip is to simplifiy your test case and slowly build back to your current test case to get an idea of which part of the test case may be causing the issue."}, {"id": 1938, "value": ""}, {"id": 1939, "value": "Yes - as that is a part of the class invariants you are responsible for handling. In that case, after you do `push_front()`, the size of your list must be incremented. Now think about other member functions in which you'll need modify `size`."}, {"id": 1940, "value": "If you want to go beyond the requirements of the project, you can check out the \"You don't need to handle these errors\" part of error handling section in the spec: https://eecs280staff.github.io/p4-web/#error-handling. . You will notice that public_error01 is an example of a request in which the content-length is incorrect, which the spec says that you do not have to check for.. . Edit: my mistake, public_error01 is a valid test case. Check follow ups for details"}, {"id": 1941, "value": "If you are defining the method outside of the class, you have to use scope resolution so that the compiler knows which class the method is a part of.. Since copy_all is a part of the List class, we should use. . List<T>::copy_all. instead of. . copy_all. "}, {"id": 1942, "value": ""}, {"id": 1943, "value": ""}, {"id": 1944, "value": "If you have an uninitialized json object, it should evaluate to null.. For example:. . json j;. json response = {. \t{\"count\", <some number>},. \t{\"rseults\", j}. }. Hope this helps!"}, {"id": 1945, "value": "As per the spec, delete request responses should have consistent formatting regardless of the number of people in the queue, unless the queue is empty (400 error)"}, {"id": 1946, "value": "Use your best judgement when deciding whether to use iterators for these functions. How should you go about inserting an element at the beginning or end of the list, and how may that differ from inserting into the list? If using an iterator wouldn't make sense in a certain scenario, then you can probably assume you won't have to use one."}, {"id": 1947, "value": "As per the information from your variables window in the debugger, `node_ptr` in `iter` appears to be a `nullptr`."}, {"id": 1948, "value": "Per the spec, you can assume that HTTP requests are always properly formatted. Thus, you can use the `Content-Length` header to determine how long the request body is, regardless of whether the request path/method is valid."}, {"id": 1949, "value": "@3245. There should more bugs that can potentially exists other than the 21 required for full points"}, {"id": 1950, "value": ""}, {"id": 1951, "value": "List is a templated class, so make sure you're using template type T rather than type int"}, {"id": 1952, "value": "The students' answer did a pretty good job explaining, which corresponds to your second illustration."}, {"id": 1953, "value": "Can you make sure that in your `push_back` function, `last` points to a valid (last item) in your list? If not then `last->next` will cause a segfault because it is a `nullptr`"}, {"id": 1954, "value": "This is because you have not implemented the constructor for `List::Iterator` on line 213."}, {"id": 1955, "value": "1. More accurately, it returns an Iterator that points to a null pointer. Besides that, I believe your understanding is correct. . . 2. The iterator is provided for the user to traverse the list, and the end() function is meant to let them know that they have traversed to the end of the list (and should NOT go any further). Since you designed the whole List structure, if you want to return a pointer to the last element, you can just use the **last** pointer stored in your List class, which you should actively track where it points to any time the list gets modified."}, {"id": 1956, "value": ""}, {"id": 1957, "value": "It looks like you're passing a string into a `json` variable that isn't actually JSON data. Double check your logic around where you construct and feed data into `json` variables. You can check the working with JSON tutorial on the 280 website also."}, {"id": 1958, "value": "Pay careful attention to make sure you assign the prev/next variables correctly when you copy. That being said, it's hard to know the exact issue without seeing the code. You could try making a private post with you code and asking an instructor for help."}, {"id": 1959, "value": "Bad access could come from trying to access the prev of a nullptr. Make sure the line first->prev never executes if first is a nullptr."}, {"id": 1960, "value": "your approach on checking if first last or else seems like it would work considering your first and last work"}, {"id": 1961, "value": "nevermind I fixed it!"}, {"id": 1962, "value": "I think the \"{}\"s count as characters, so in this case Content-Length is correct!"}, {"id": 1963, "value": "nevermind i got it!"}, {"id": 1964, "value": "Yes; if you are `insert`ing at the end, just treat it like `push_back`.. . ![image.png](/redirect/s3?bucket=uploads&prefix=paste%2Flcij6xuzlgl373%2Fb44410c9714e8f93d06da77e9295ed72902d89bef29a2cf6077711146e112647%2Fimage.png)"}, {"id": 1965, "value": "I just cleared the queue for today, the problem should be fixed:)"}, {"id": 1966, "value": "yes."}, {"id": 1967, "value": "I would reference the JSON Writing to a stream tutorial for the correct way to output nested JSON objects. One potential issue with what you have could be that you are pushing back a json obect to itself. However, if you are encountering weird issues like this or the issues in the follow ups, the best course of action to take is stepping through your code through the debugger to see what variables are set to. This way you can identify the source of such undefined behaviors."}, {"id": 1968, "value": ""}, {"id": 1969, "value": "This error is saying you are trying to compare a string with a List. See if you can identify which line this comparison is happening on and make sure both sides are of the same type."}, {"id": 1970, "value": "@3245"}, {"id": 1971, "value": "In lines 282 and 283, you called erase on it1 and it2.. . Then in lines 287 and 288, you called erase on it1 and it2 again. But notice that you haven't updated it1 and it2 since you last deleted it."}, {"id": 1972, "value": "The problem isn't a compile error, rather its a runtime error. This means that the logic of your code is wrong and likely doesn't assign your pointers correctly."}, {"id": 1973, "value": "Yes."}, {"id": 1974, "value": "This doesn't seem like an error with your test case. If my_list is created as dcba as you mentioned, then --i3 on line 127 should make i3 point to d."}, {"id": 1975, "value": "Do you have Python installed? This error generally indicates either the left or right side of a command pipeline failed; so, either your api.exe failed or the python wrapper failed, in this case. Since your api.exe is probably correct, check to make sure you have Python installed properly."}, {"id": 1976, "value": "No"}, {"id": 1977, "value": "If you look at autograder it should automatically make the adjustment for previous submissions"}, {"id": 1978, "value": ""}, {"id": 1979, "value": "Remember that end() returns an iterator to a Node \"one past the end\" of the list, and insert() adds an element \"one before\" where the iterator is pointing. With this in mind, can we safely dereference an iterator pointing one past the end of the list? Is \"it\" being updated after the insert() call, or is it still pointing to \"one past\" the end of the list?"}, {"id": 1980, "value": "Could you make a private post sharing your parsing logic, please?"}, {"id": 1981, "value": "You can try copying the format of the public test files and modifying/adding on to them to build more robust tests. Since manually writing tests for the driver can be tedious, I recommend you look into mutation testing. (Though frankly, you may find such testing overkill, since many of the endpoints (particularly the GET ones) are idempotent, and the ones that do modify state [DELETE and POST] are likely correctly implemented if they work on existing tests)"}, {"id": 1982, "value": "Your code looks good so far! Assuming that your Student struct has member variables for location, position, and uniqname, your approach makes sense. If you're not sure how to get a student's position, the position should correspond with a students index in the list--i.e., the first student in the list is position 1, second student in the list is position 2, etc. Once you've built the json array, you can use it as the value for the \"results\" portion of the output"}, {"id": 1983, "value": "Could you make a private post sharing your loop logic for adding each student to results, please? It's possible your method for looping has an off-by-one error."}, {"id": 1984, "value": "No you should not use List.h that you implemented but the list from stl. In order to get the first student, you can use the front() function supported by the stl. You may find this link helpful."}, {"id": 1985, "value": ". \"// add any friend declarations here\". Iterator class should give its \"friendship\" to List class.. "}, {"id": 1986, "value": "Without looking at your code in detail (come to OH if this doesn't solve your problem), it looks like you are at the wrong position in `cin` when trying to read into a `json` object. `json` objects start with an opening brace `{`, but it looks like you started on `C`."}, {"id": 1987, "value": "I would look through your code and make sure that every line of code is tested by some test. Specifically, I'd look at all if else statements that you wrote and make sure that some test causes each if/else statement to run."}, {"id": 1988, "value": "Yes, implement all of the functions they give you, but don\u2019t add any helper functions to your list."}, {"id": 1989, "value": "What this means is you are calling delete on a pointer twice. For example:. . int* x = new int(5);. delete x;. // other code. delete x; // this is a double free error. . This is most likely happening because you are calling erase on two iterators that essentially \"point\" to the same object. I would recommend using your debugger to better understand what is going on."}, {"id": 1990, "value": "Resolved!"}, {"id": 1991, "value": "Yes. Any variables in the class definition would get automatically constructed.\u00a0. . An important side note:. If you do not use an initializer list in the original class constructor, all objects inside the class will be default constructed. If you would like to use a custom constructor for a member variable, you would need to specify in the initializer list for the original class's constructor.\u00a0. "}, {"id": 1992, "value": "If you have a large amount of code in your main() function in api.cpp, there are a few strategies you can use to simplify and organize your code:. . Break up your code into smaller functions: If you have a large block of code that performs a specific task, consider refactoring it into a separate function. This will make your code more modular and easier to read.. . Use helper functions: If you have a common pattern of code that you use in multiple places, consider creating a helper function that encapsulates that pattern. This will help reduce duplication and make your code more concise.. . Use data structures to organize your code: If you have a lot of related data and operations, consider creating a data structure to represent that data and encapsulate the related operations. This can help simplify your code and make it more modular.. . Overall, the key to reducing the amount of code in your main() function is to break it up into smaller, more manageable chunks and to use control structures and data structures to simplify your code."}, {"id": 1993, "value": "Another option is to set \"External Console\" to true. Remove the extra stuff from \"args\". Hit the \"start debug\" and a new terminal window should pop up. Copy the contents of the test case and paste it into the terminal window. At the end of the test case in the external console, add EOF character (Control + D). It should be able to read in from cin now.\u00a0. . Follow up if that doesn't work!"}, {"id": 1994, "value": "If you are having trouble opening standard library files and have lost your include path on your Macbook, there are a few steps you can take to troubleshoot the issue:. . Check if the standard library files are present: Make sure that the C standard library files are still present on your system. These files are typically stored in the /usr/include directory. You can check if they are present by opening a Terminal window and running the command ls /usr/include.. . Check your include path: Check your include path to make sure it is set correctly. You can check your include path by opening a Terminal window and running the command echo $C_INCLUDE_PATH. If the output is empty or does not contain the correct path to your standard library files, you may need to set your include path manually.. . Set your include path manually: If your include path is not set correctly, you can set it manually by opening a Terminal window and running the command export C_INCLUDE_PATH=/usr/include. This will set your include path to the default location for the C standard library files.. . . For more indepth help, please go to OH."}, {"id": 1995, "value": "You should always return 0. If you are given any invalid request, you should print out a bad response (as specified in the spec https://eecs280staff.github.io/p4-web/#error-handling) and then continue to read in requests. This is similar to how a normal OH queue would work. If someone tries to join the queue but accidentally sends a bad request, the entire OH queue doesn't just shut down.. . You can always guarantee that the request header will have all the parts so you do not need to consider a case where you are only given a method. This is what we mean by requests being properly formatted."}, {"id": 1996, "value": "Try only reading in 4 lines (or 3 after you read in the first one). If you do getline again, it will read in the first {. Then when the json tries to read in, it will throw an exception because it needs to read in {}."}, {"id": 1997, "value": "In general, when you erase a node from a linked list, any iterators that point to that node become invalid. This means that you should not attempt to dereference or use an iterator that points to an erased node.. . However, erasing a node does not delete the iterator itself. The iterator remains valid, but it points to an undefined location in memory. If you attempt to dereference an invalid iterator, your program may crash or exhibit undefined behavior.. . To avoid using invalid iterators after erasing a node, you should reset the iterator by setting it to .end() or .begin()."}, {"id": 1998, "value": "In the comment for the -- operator, it says that \"// Requires that the current element is dereferenceable.\". We require the given iterator to be dereferencable. An iterator pointing to \"one past the end\" is not dereferencable."}, {"id": 1999, "value": "It looks like your test cases aren't being submitted because you have a compile error in your list tests. You cannot compare an iterator to nullptr. To see if the iterator is pointing to a nullptr, you should assert that iter == linked_list.end()."}, {"id": 2000, "value": "The type T is declared at the top of the starter files in the line just before \"class List {\". We declare it like this:. . template <typename T>. This basically tells the computer that we intend for the user to give us a type, and since we cannot know beforehand what type the user will give us, we will use T as an alias for the type. So if the user created a List<int>, then T would be an alias for int.. . . how we use datum in push_front (like is it a node at all?). . . In push_front, we want to add a new Node to our List. We know that Node has an attribute called datum, which is of type T. Make sure that when you create the Node, you set its datum to be whatever is passed into push_front."}, {"id": 2001, "value": "I would suggest having a function for each of the request types your code must handle."}, {"id": 2002, "value": "You are correct that the linkedlist could possibvle take in a different data type. We account for this using generic programming. In the starter code, you will notice that we use T to denote the data type that the user specifies, and the datum field of a Node is defined as type T.. . Also consider whether it would be appropriate here to return a copy or a reference. I will leave this for you to think about..."}, {"id": 2003, "value": "If there are any instances where you forget to increment your length variable, the autograder will catch that as a memory leak, even if the rest of your memory diagram is correct."}, {"id": 2004, "value": "This is a tricky error! The operator overload for a prefix and a postfix decrement is different. The operator overload you have defined is for a prefix decrement, but the one you use in the insert function is a postfix decrement. Try changing i-- to --i. Follow up with any additional questions!"}, {"id": 2005, "value": "Actually, I solved my problem after some research and looking at the spec. Just put using namespace nlohmann; and it should work!\u00a0. "}, {"id": 2006, "value": "From what I know in lecture and OH it is saying don't change the list class like changing the function input or output or where they are put in the class. You can implement the function where they are, but you can't change the parameters of the functions and things like that.\u00a0"}, {"id": 2007, "value": "I think you should be able to initialize an iterator with begin, even for an empty list. I just set it to point to nullptr.. Someone who know more about this can correct me if I am wrong"}, {"id": 2008, "value": "If you are implementing the methods inside the class definition, you will not need to write \"template<typename T>\" before every function.. If you are implementing the methods separately outside the class definition, then you will need to write \"template<typename T>\" before every function.. . As for the List<T>::, note that this is not the return type. In the example in the screenshot, the return type is bool, and List<T>:: is using the scope resolution operator (::) to tell the compiler that empty() is a method of the class List<T>.. If you are implementing the methods inside the class definition, you will not need to use this scope resolution.. If you are implementing the methods separately outside the class definition, then you will need to use this scope resolution."}, {"id": 2009, "value": "Remember that at the end of the function, we implicitly call the List destructor (the List object is destroyed as it goes out of scope).. It may be worth taking a look at your destructor implementation to see if you can spot anything fishy.. Note, though, that your destructor may actually be correct, but producing a segfault because of something that push_back didn't quite handle.. I would recommend taking a close look at push_back and the destructor by running the debugger on this test case."}, {"id": 2010, "value": "Hey, if you haven't found a partner yet, my email is chiderao@umich.edu. I live in Bursley but I'm free to meet anywhere."}, {"id": 2011, "value": "Thanks for pointing this out!. We are aware of this issue with the autograder; we will make an announcement soon about how we will deal with this."}, {"id": 2012, "value": "You don't need to, but it's recommended that you create a size member variable within your List class to keep track of the number of nodes in an efficient manner"}, {"id": 2013, "value": "If the queue is empty, the response should be:. HTTP/1.1 200 OKContent-Type: application/json; charset=utf-8Content-Length: 40. {\u00a0 \u00a0 \"count\": 0,\u00a0 \u00a0 \"results\": null}. However, in every other case, make sure you're adding all of the results to this output."}, {"id": 2014, "value": "I don't think I can comment on how you do your code, but I think you should change how you are doing your while loop that maybe you should read in some variables in there. I would also go to OH to get more detail and structure from an IA.\u00a0"}, {"id": 2015, "value": "Unfortunately, there isn't a specific lecture because the professor did say that we could do the api driver without learning anything new because all the skills needed are either provided in the spec with documentation or the logical concepts (reading in and writing files) have already been covered.\u00a0"}, {"id": 2016, "value": "Yes. You may hardcode this, but it is also similar to other requests. Therefore, you can choose to combine this response with others for a better design."}, {"id": 2017, "value": ""}, {"id": 2018, "value": "Resolved"}, {"id": 2019, "value": "You should be using the standard library list - not the one that you implemented"}, {"id": 2020, "value": "24"}, {"id": 2021, "value": "A segmentation fault occurs when you are trying to access \"invalid\" memory (memory that you do not have permission to access). One common example of this in Project 2 was when you where trying to index \"past the end\" of an array.. In the context of project 4, a common case for segmentation faults could be when you try to dereference a nullptr. Look through your List.h code and see if there are any edge cases that you may not be accounting for.. Hope this helps!"}, {"id": 2022, "value": "Just checked your autograder submission; this seems like the expected behavior. Look through which parts of your code would run when it receives a POST request, and keep an eye out for any extraneous couts that you are doing. It looks like there is an extraneous cout that you probably added for debugging then forgot to remove. Hope this helps!"}, {"id": 2023, "value": ""}, {"id": 2024, "value": ""}, {"id": 2025, "value": ""}, {"id": 2026, "value": "I highly recommend checking out the JSON tutorial: https://eecs280staff.github.io/p4-web/json.html"}, {"id": 2027, "value": "Your test case file is not compiling, please refer to the error messages given in autograder"}, {"id": 2028, "value": "See https://eecs280staff.github.io/notes/17_Iterators.html and control-f 'postfix' -\u00a0 it uses an int parameter to differentiate the two. But im not sure if we have to implement the postfix or the -> operator? Correct me if im wrong though."}, {"id": 2029, "value": "No. You are making a list to demonstrate that you know how a linked list works and how to implement one. In your api.cpp, you should use the standard library\u2019s list.. . Edit: C++ already has a standard library for list, so you should just use that. But, after you finish implementing both List>h and api.cpp, you can try to run api.cpp using your own List.h to test it if you want. But keep in mind you can't use post-increment operator or -> operator because we havent really overload these 2 operators"}, {"id": 2030, "value": "Note erase and list is a public function of the List class.. \"Are we erasing and inserting where i is pointing at\":. \u00a0 There is explanation in the RME's, but basically erase function works by erasing i, so you are right. But, insert function work by inserting the element, 1 place before i.. \"How do we go about deleting/inserting the values in\":. \u00a0 Generally:. \u00a0 \u00a0 \u00a0delete: modify the \"prev node\" and \"next node\" of the node you are deleting (i.e. linking them together) and then delete the node. \u00a0 \u00a0 \u00a0insert: create a new node and modify it so it is positioned before i. This can be done again by tweaking the next/prev pointer. \u00a0 \u00a0Plus: there is some special cases where you should probably modify first and last,\u00a0"}, {"id": 2031, "value": "Are you freeing all the nodes in the list you are copying to?"}, {"id": 2032, "value": "Looks like you don\u2019t have the c++ extension installed for VSCode\u00a0"}, {"id": 2033, "value": "solved"}, {"id": 2034, "value": "Your output is correct here, your exit status is not. Everything you're printing is the exact same as what we're expecting, but the code is exiting with an error."}, {"id": 2035, "value": "To answer your question, You should.. . There's bug in your code, consider if there's only 1 element in the list and you pop_front(), what else do you need to update?"}, {"id": 2036, "value": "Seems like you've fixed it, Mark as resolved"}, {"id": 2037, "value": "I think you are correct. This is also consistent with this part of the spec:. . If one of the errors above occurs, read the remainder of the request, including any headers or body. Then, return the following response after reading the entire request. Note that there is a blank line after\u00a0Content-Length: 0.. . "}, {"id": 2038, "value": "It's most likely you are trying to read into a json object when you are not actually giving input stream a valid json object. Try to  use visual debugger and set a break point at where you try to read into a json object."}, {"id": 2039, "value": "Marking as Resolved."}, {"id": 2040, "value": "\"You do need to take into account empty lists in the insert operation. Note that an iterator to the beginning of an empty list is\u00a0valid but it is not\u00a0dereferenceable.\". This is the instructor's answer, so you DO NEED to consider when the list is empty. I guess if you have an iterator to the beginning of an empty list and use it for insert, you just need to insert the new element as the only element. So now it is a list of 1 element."}, {"id": 2041, "value": "try just doing OHQueue queue;\u00a0"}, {"id": 2042, "value": "I believe list.end() will return a pointer to a \"pass the end\" element, which in this case is nullptr. So, you cannot dereference i because its pointing to nullptr i.e. i doesn't have a node_ptr in it. So, you should probably use a different if condition e.g. i.node_ptr == nullptr.. Edit: Yes, for erase you don't need to consider when i is pointing to nullptr i.e. list.end() or list. Begin() if the list is empty"}, {"id": 2043, "value": "Are you asking why `auto j = i` would make j an int? I am not sure if that's correct. Because `auto i = fl.begin()` makes i an iterator. So j should also be an iterator. Since j is an iterator, we can use `++j` to increment it, as stated in the comment."}, {"id": 2044, "value": "I don't think you should do this and this would definitly give you a seg fault. In `push_front()` you need to access ```datum```, and nullptr doesn't hold valid datum."}, {"id": 2045, "value": "resolved - 280 bot"}, {"id": 2046, "value": "You're correct that both `i1` and `i2` will point to `nullptr` when the list is empty.. . This is not an issue you need to solve, and is as intended. When you modify the list content via `push_back`, `insert`, `erase`, etc., iterators created prior to that change should be considered _invalidated_. Using an iterator after modifying the list is undefined behavior, and as such you do not need to account for this in `List.h`. Users of your `List` class should re-define their iterators after modifying the list to make them valid again."}, {"id": 2047, "value": "Sometimes it takes a run through of your code to make the error messages pop up. What are your current compiler sources?\u00a0"}, {"id": 2048, "value": "If you go to setting and search \"error squiggles\", you can enable it. Try to quit and restart vscode also helps."}, {"id": 2049, "value": "Hi! Thanks for the question. You can push_back() items into a json. For example, if I have:\u00a0. . json results;\u00a0. json entry;\u00a0. . I can push_pack an entry into the results like this:\u00a0. . results.push_back(entry);\u00a0. . I hope that helps!"}, {"id": 2050, "value": "You should select \"Connect to WSL\" and click \"Open folder\" when it connects. Make sure that you do not click \"Show in local\", but instead enter your complete file path to your project folder (usually starting with /mnt/c/Users/) in the text box."}, {"id": 2051, "value": "Hi! Thank you for your question. I'd recommend looking at the project overview video, which is about a half hour long. That would be a great way to get started on the project. I'd also be sure to make sure you take full advantage of office hours, as the wait times are pretty light at the moment. You're always welcome to come and ask for a general overview of a project if you don't understand it. Lastly, if something urgent comes up, you can ask for a project extension with the form on our site.\u00a0"}, {"id": 2052, "value": "Moving followup to solution but I cannot test it locally, so if this does not fix the issue please follow up. If you have an M1 chip Mac you should try with this launch.json configuration.. . {. \u00a0 \u00a0 \"version\": \"0.2.0\",. \u00a0 \u00a0 \"configurations\": [. \u00a0 \u00a0 \u00a0 \u00a0 {. \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"type\": \"lldb\",. \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"request\": \"launch\",. \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"name\": \"Debug\",. \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"program\": \"${workspaceFolder}/api.exe\",. \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"args\": [],. \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"stdio\": [\"main_test.in\", null, null],. \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \"cwd\": \"${workspaceFolder}\". \u00a0 \u00a0 \u00a0 \u00a0 }. \u00a0 \u00a0 ]. }"}, {"id": 2053, "value": "This error could be because you're returning the wrong type. Maybe you forgot to dereference a pointer or something along those lines.\u00a0"}, {"id": 2054, "value": "You\u00a0should\u00a0consider self-assignment of List and probably the easiest way to do it is by creating an if statement at the start of the = operator overload, just like shown in the asynchronous lecture by prof. Juett"}, {"id": 2055, "value": ""}, {"id": 2056, "value": "An iterator can be used to loop through a container class. In this case, you are using the iterator to loop through the list class. It also lets you access/remove/insert elements anywhere in the list as well.. . Adding on to this, you might also want to review this week's lecture on iterators, and this week's lab covers them as well!"}, {"id": 2057, "value": "First and last would both point to that one node in the list."}, {"id": 2058, "value": "Yes, insert should be able to handle insertions where i is the end iterator. As you mention, the list should insert the value at the end of the list."}, {"id": 2059, "value": "Your \"copy_all\" function is not completed, so the compiler is getting very confused. Here is what I am seeing:. . . "}, {"id": 2060, "value": "It is not compiling. Make sure to compile locally and on CAEN before submitting"}, {"id": 2061, "value": "@3134 and the spec here address this! Feel free to start a followup if you have any more questions"}, {"id": 2062, "value": "The issue seems to be that you are dereferencing an iterator after the pointer the iterator stores has already been freed. Make sure you aren't using any iterators with pointers to deleted memory."}, {"id": 2063, "value": "It looks like your overloaded * operator is returning a List<int>::Node, instead of an int. Make sure your * operator returns the\u00a0datum of the node, not the Node struct."}, {"id": 2064, "value": "The class isn't List, it's technically List<T>. Therefore, if you define functions outside of the class scope, you'll have to do it like the following:. . . template<typename T>. void List<T>::pop_front() {...}"}, {"id": 2065, "value": "Let's resolve this in @3209..seems like this the same post"}, {"id": 2066, "value": "We do not move this iterator so it still points to the node that you just erased, which means it no longer points to a valid object. You may not want to apply operators like ++, * etc. that require validity on this iterator."}, {"id": 2067, "value": "Please update your name on Piazza to include your uniqname as in @64. This helps us find you on the autograder to take a look at your code if we need it to help answer your question!. . From what I'm seeing in the error and looking online, it looks like you need to overload the operator== for your Student class that and have it take in a const Student. Some of the stl functions, including remove, require a const reference as a value to compare against.\u00a0. . These posts provide some more detail and should be helpful:. Removing element from vector: Invalid operands to binary expression (stack overflow). Calling erase with iterator vs const_iterator (stack overflow). std::find, invalid operands to binary expression ('Foo' and 'const Foo') (Reddit). . "}, {"id": 2068, "value": "GET /api/ will always return the same data.. So the local host links returned are always the same."}, {"id": 2069, "value": "Yes, you are able to use the code that you see in lecture and on lecture/lab slides.. . However, there is a much simpler approach to the size() function in List.h. Remember that you can't modify the public interface of List.h, but you can add private member variables or functions where you see fit."}, {"id": 2070, "value": "I'd make sure the implementations in List.h follow the original specifications to make sure you get all the points on the autograder."}, {"id": 2071, "value": "Indexing requires the elements to be contiguous in memory, so that once you know where the head is and the index, you can directly look for the element at the destination address.. Since list nodes are not contiguous in memory, even though we know head and index, we cannot directly compute the destination address and look for it. We have to access each node to get the address of the next node until we reach the destination (e.g. having done this index times)."}, {"id": 2072, "value": "I'm not exactly sure I've understood your question completely, but if you are storing students in an array, then that might not be the best strategy.. You are correct that arrays have the problem of being fixed in size, and that's why we don't want to use arrays when we need to insert and remove elements frequently.. In this project, we've specifically asked you to store students in a list, which is dynamic in size. If you are storing students both in a list and an array, then think about if it is necessary.. Feel free to post follow-ups if I'm not answering your question."}, {"id": 2073, "value": "From input stream, which is most likely cin in this case."}, {"id": 2074, "value": "Yes, you should maintain the invariant that first always points to the first element of the list and last points to the last element of the list when pushing and popping."}, {"id": 2075, "value": "You should read the requests that contain properties like the method and path from standard input using cin."}, {"id": 2076, "value": "cin. See this from the slides:. . Basically:\u00a0 while(cin >> method >> endpoint) "}, {"id": 2077, "value": "If there is a mismatch between an endpoint and a method, or invalid endpoint or method, you should use bad request.. . Ex. if the endpoint is /api/adfasfd you'd say its a bad request or if the method isn't get,post,etc. . "}, {"id": 2078, "value": "What this means is that ptr is a null pointer, and you are trying to dereference it with \"ptr->next\" which is not allowed. This threw an exception."}, {"id": 2079, "value": "Yes, delete should always have a content-length of 0. Content-length corresponds to the length of the returned json body of the response not including headers, and delete does not return a json body."}, {"id": 2080, "value": "What you can do is use copy_all in the implementation of your copy constructor and then test the copy constructor to make sure it works as intended."}, {"id": 2081, "value": "Since everything is read through \"cin,\" you are correct in that the only element in argv will be \"./api.exe\" (or something similar).When reading in a request, the JSON library will only accept input that is formatted as JSON. In other words, you *have* to read the headers in as strings (two of which you will save, the rest can be ignored/discarded). Once the headers have been read in, you can simply call \"cin >> body\" (where \"body\" is of type \"json\") to read in the JSON body of the request into the \"body\" variable. These steps can then be repeated in some form of loop in order to read in all of the requests."}, {"id": 2082, "value": "Insert is supposed to make space and then insert the element before the Iterator. To get started, there are three cases I would check (iterator is pointing to the first in the list, the last in the list, or otherwise in between). You can make use of the push and pop functions you implemented in List in some of these cases."}, {"id": 2083, "value": "copy\\_all is private because it is a helper function for the list implementation. (ie. you can use it in your implementation of the big three, if you decide the big three is needed). We do not want copy\\_all to be public because it copies all nodes in the list, which breaks the interface of list.h. Remember, we don't want the individual nodes of the list to be _directly_ modified/accessed by any random user of the list.. . If you write the big three for this project, it should be public. This is because the big three provides the tools needed to use the list properly for any person using the class. Otherwise, any person trying to use our list would run into errors where they would not be able to assign/copy variables, or properly destroy variables when they exit scope. This would defeat the purpose of having a publicly accessible list!. . Hope this helps!"}, {"id": 2084, "value": "It looks like the compiler thinks you are trying to dereference into a function pointer, most likely caused by a syntax error in your code.\u00a0. . You should put your unique name in your piazza so we can look you up on the autograder"}, {"id": 2085, "value": "This is most likely caused by the json \"J\" not having the key \"location\""}, {"id": 2086, "value": "I'm still looking for a partner, my email is chiderao@umich.edu"}, {"id": 2087, "value": "Nope, you don't need to use it in List, Iterator, or the API! It would be a good idea to test your erase() implementation though."}, {"id": 2088, "value": "You don't need to use getline() in this file. cin >> can do all the work. The valid format is given, and you may count how many times you may need to call cin >> to read all \"junk\" content until it runs to the json contnet."}, {"id": 2089, "value": "You may need to show the code in the test case for more context.. However, when you use ++i, --i, you are moving the iterator to point to something else. So in your case, if you have --i and then ++i, ideally, i will be pointing to the same node. You should avoid modifying i in your erase as this is not mentioned in the RME. Considering using ->prev and ->next instead. ->prev->next is also a valid expression (think about why)."}, {"id": 2090, "value": "The error message here indicates that your function isn't marked as const. Because operator== shouldn't be making any changes to the iterator, it is important to mark the function as const. You would do this by adding a const to the end of your function signature. Feel free to follow up or look over lecture 17 slides/ recordings for more clarification. Also note that it's ok to pass by const reference (as you did here) but convention is to just pass iterators by value. There isn't anything you need to change, but just letting you know that there is another valid (and likely more common) way to implement operator==."}, {"id": 2091, "value": "The JSON object won\u2019t be too too large, hence it can just be a variable on the stack. No need to allocate dynamic memory for it.\u00a0"}, {"id": 2092, "value": "Copy and paste is fine."}, {"id": 2093, "value": "Did you check out this link? https://github.com/microsoft/vscode/issues/115818. . It seems to be a bug in VScode. They are recommend downloading the 1.52.1 (older version) (link: https://code.visualstudio.com/updates/v1_52) and this seems to solve the issue.\u00a0"}, {"id": 2094, "value": "As long as there is still something, i.e., not EOF, the loop condition will evaluate to true. One thing to notice, though, is that if you do this while (cin >> myVar), then the value will be directly read into\u00a0myVal\u00a0and cannot be re-read.\u00a0while (cin)\u00a0usually does what you want."}, {"id": 2095, "value": "Within the List class, you are able to access the private Node struct. So you can do things like:. . Node *node_ptr = first->next. You also have access to the first and last node pointers along with num_nodes because you are working within the List class."}, {"id": 2096, "value": "Yes, the expected output is. . . "}, {"id": 2097, "value": "you can use iostream and sstream"}, {"id": 2098, "value": "i is an iterator but not a pointer so u should consider i.node_ptr"}, {"id": 2099, "value": "if u r implementing it inside the class u don't need List<int>::"}, {"id": 2100, "value": "I would walk through with your debugger. It\u2019s hard to say exactly what it could be, but typically these types of errors are the result of incorrectly/forgetting to update pointers. Ex. Two items in a list, and you delete the last element. If you don\u2019t update next for the first element, when you go to run clear, you\u2019ll get an error like the one above.\u00a0"}, {"id": 2101, "value": "@3129"}, {"id": 2102, "value": "You added a function to your List.h class (is_last_null) that does not exist in the instructor code. So, when the autograder tries to run the instructor buggy solution with your test cases, it can't compile.\u00a0"}, {"id": 2103, "value": "It is usually due to uninitialized variables. If you are using a variable to keep track of position, make sure you have initialized it correctly."}, {"id": 2104, "value": ""}, {"id": 2105, "value": "solved"}, {"id": 2106, "value": "What `push_front` does is add an element to the front of the list. Because it's a linked list, all you need to do is create a new node and adjust the pointers accordingly. There isn't a need for a `delete` simply because we are not deleting any nodes! The deletion of nodes is handled in other function where we want to get rid of one or more nodes, such as `pop_front`, `pop_back`, or the destructor."}, {"id": 2107, "value": "resolved"}, {"id": 2108, "value": "Unfortunately, no (the Autograder won't allow it). Managing dynamic memory is one of the core principals of the List we ask you to build out, so we require you to use normal pointers so you can get a good understanding of how to create and delete dynamic memory safely."}, {"id": 2109, "value": "You are only supposed to use the standard library list in your api.cpp."}, {"id": 2110, "value": "Yes"}, {"id": 2111, "value": ". for (auto it =[name].begin(); it != [name].end(); ++it). . (note that name is the name of your list variable"}, {"id": 2112, "value": "Marking as resolved!"}, {"id": 2113, "value": "If you do not see the point in having a list of Students, you don't have to implement your solution that way! It's merely a suggestion. Have an interface/class such as student might make your code more readable as it clearly defines what properties belong to each student, but you won't have any points taken off of your solution if you don't have one."}, {"id": 2114, "value": "Even though there's an equals sign, we are still setting one object equal to another upon *initialization*. That's the key difference between assignment operator and copy constructor. If we are copying upon initialization then it's copy constructor, if we are copying when the object has already been initialized then it's the assignment operator."}, {"id": 2115, "value": "You only need to add this to your argument option:\u00a0< filename"}, {"id": 2116, "value": "Make sure you have implemented the function. This could also just be a VSCode Intellisense error, in which case just see if it compiles in the terminal."}, {"id": 2117, "value": "Could you provide more context for when the error is happening? Do you know what function it's stepping into before it gets to this error? Feel free to make a private post with some of your code!"}, {"id": 2118, "value": "You would need both, remember that both next and prev are Node pointers that you wouldn't want to be filled with expired data."}, {"id": 2119, "value": "The second line you wrote would be correct since the point of\u00a0operator==\u00a0is to return true or false (depending on if the 2 things are equal). If you don't pass anything to the function, how do you know what you're comparing to? You'll only have 1 side of the\u00a0lhs == rhs\u00a0expression."}, {"id": 2120, "value": "The both can detect undefined behavior, while leak checking programs can additionally check for memory leak, i.e., dynamically allocated objects not deallocated after use."}, {"id": 2121, "value": "Update: I fixed it. It was a problem in my extraction operator function so it wouldn't complete the cin check in order to decide whether or not to go back into the loop.\u00a0"}, {"id": 2122, "value": "This would fall under the error \"HTTP method is not appropriate for the path. For example, POST /api/.\" in the spec here.. . This is not a valid request that you need to set up a route for, but you still need to account for it as an error. You should return a 400 Bad Request response like in the spec but do not add someone to the head of the queue.. . DELETE /api/queue/tail/ is the same, not an appropriate method for the route, same as POST /api/queue/head/ ."}, {"id": 2123, "value": "As I understand it, no -- all our implementations will also go in List.h. :)"}, {"id": 2124, "value": "If i(w) is the first node in the list, then u would be a nullptr and thus cannot be dereferenced. u->next is a bad access."}, {"id": 2125, "value": "It's hard to tell just based on your autograder submission, but my guess is that a different function (maybe push back or pop back) is not correctly setting the `prev` and/or `next` pointers? If you need further help with this, I recommend coming to office hours."}, {"id": 2126, "value": "it1 is an iterator pointing to a node. After you erase\u00a0the node it1 points to(you are not erasing it1 itself),\u00a0you can no longer access the node, but you can freely change the node it1 points to.. It is the same for pointers: say ptr is a pointer that points to a dynamically allocated object. When we\u00a0delete ptr;, we are not deleting ptr itself but the object ptr points to. Then that object is no longer accessible, but you can freely let ptr point to other objects."}, {"id": 2127, "value": "This would really depend on the implementation and structure of your code. You will most likely need this `while` loop somewhere in your overarching class that takes care of reading requests from input. After you read the input with `cin >> method >> endpoint`, you should be able to determine what the request type is and continue with the next steps (perhaps reading the `content` of that request, if any)."}, {"id": 2128, "value": "Yes! Refer to [this section](https://eecs280staff.github.io/p4-web/#request-format) in the spec for more information."}, {"id": 2129, "value": "As long as your input is in JSON-format, the following should work for you and you wouldn't need the bracket finder:. . ```c++. json j3;. cin >> j3;. ```"}, {"id": 2130, "value": "I think you might have trailing white spaces after each comma in `js2`"}, {"id": 2131, "value": "This seems like a question to ask at office hours. We'll be able to look at whatever else you have and see what may be causing this."}, {"id": 2132, "value": ""}, {"id": 2133, "value": "You'll need go into `launch.json` and make changes to the line where it says `stdio`. Change it into the following format if you want to use `test01.in`, for instance:. . ```json. {. .... \"stdio\": [\"test01.in\", null, null],. .... }. ```"}, {"id": 2134, "value": "I believe this is stated in the spec and you are correct."}, {"id": 2135, "value": "This is the suggested way to approach this, yes"}, {"id": 2136, "value": "In both of these functions, the return type should be `bool`, not `Iterator`."}, {"id": 2137, "value": "You're right that some of the information given to you is not necessary to process. I think this would be a good way to get around this."}, {"id": 2138, "value": "Because there could be another valid request (or even another bad request) after the bad request\u00a0"}, {"id": 2139, "value": "Yup, the only parts of the request that change are the method (get/post/delete), path (api/\u2026) and content length. Everything else like the version is the same\u00a0"}, {"id": 2140, "value": "I think the program should continue to read requests until the end of the file"}, {"id": 2141, "value": "I highly recommend checking out the JSON tutorial: https://eecs280staff.github.io/p4-web/json.html. . Basically, you declare a JSON object, then just read it in. It knows to read in the entire thing. Then you can index to retrieve the desired values.. . From the tutorial:. . json j3;. cin >> j3;"}, {"id": 2142, "value": "There's no need to return Student objects from any of the member functions; I found it much simpler to return the JSON response body directly from each of the member functions within OHQueue.If you did want Student to be used within the global scope, however, it would probably be better practice to define the struct outside of the class, rather than just making it public."}, {"id": 2143, "value": "You can initialize the private member variables however you like within a constructor. From the starter files, \"You should add in a default constructor, destructor, copy constructor,\u00a0and overloaded assignment operator, if appropriate.\". . "}, {"id": 2144, "value": "You are essentially trying to access list elements by index, which is not allowed since list elements are not contiguous in memory. To get the i-th element in a list, you'll need to traverse the list by pointer(iterator) and increment it (++) i times."}, {"id": 2145, "value": "(I'm not sure if I'm understanding your question correctly, so please follow up if I didn't answer it!) You can use JSONs in your class, but you just need to print them out in the response, so you shouldn't have to return them. Check out the tutorial for more info on using JSONs in C++: https://eecs280staff.github.io/p4-web/json.html"}, {"id": 2146, "value": ""}, {"id": 2147, "value": ""}, {"id": 2148, "value": "You might be trying to dereference a null pointer, as if it was a node pointer. I would step through in the debugger to see where it fails and why."}, {"id": 2149, "value": "I would hop on office hours or post a private followup post with more details about your code. It's not possible to tell what's going on without further context.. . My guess is that there's some bug in your input reading -- specifically, I think you're probably trying to read in something as a json when it's not actually a json. For example, maybe you are reading in the HTTP headers into a json object instead of into strings?"}, {"id": 2150, "value": "Make sure you set first to nullptr when the list is created."}, {"id": 2151, "value": "I believe if a class dynamically allocates memory for it\u2019s member variables (uses new) you would need to implement the Big Three, otherwise do not.\u00a0"}, {"id": 2152, "value": "You can implement the files in either order -- as the student answer states, you'll be using std::list in api.cpp so you don't have to finish list.h first."}, {"id": 2153, "value": "Can you please hover over the red squiggle and post what the error states?\u00a0"}, {"id": 2154, "value": "The request types and routes can all be read into strings.. . See here for how to read in JSONS: https://eecs280staff.github.io/p4-web/json.html"}, {"id": 2155, "value": "Can you try `list::iterator`?"}, {"id": 2156, "value": "Because your operator function is marked as deleted (= delete). I assume you copied that code snippet from online? Delete that to fix this."}, {"id": 2157, "value": "resolved!"}, {"id": 2158, "value": "This is a tricky error. C++ prohibits member functions and variables from having the same name. You can fix this by changing the \"size\" variable name to something else!"}, {"id": 2159, "value": "You can still use and access the struct within the `OHQueue` class. In fact, the functions in that class are the only place you should directly create and modify `Student` objects."}, {"id": 2160, "value": "I would check the JSON arrays section of the JSON tutorial linked from the spec to figure this out."}, {"id": 2161, "value": "Erase and insert are actually member functions of the List class; to see why you should make note of where the Iterator class scope ends. With that in mind, it is okay to use the push and pop functions in the implementations of erase and insert."}, {"id": 2162, "value": "For the first question, yes. Assuming the list is nonempty, `first->prev` and `last->next` should always be `nullptr`.. . For the second question, I'm not sure what you mean by \"out of bounds.\" Since those mark the ends of the list, you'd only have a problem if you as the programmer try to access beyond first or last.. . For the third question, yes, you need to redirect `first->prev` to point to the new front node."}, {"id": 2163, "value": "Enable sanitizers.\u00a0"}, {"id": 2164, "value": "I believe you are encouraged to use the json.hpp library in your api.cpp file."}, {"id": 2165, "value": "Be careful about the big three. In what cases should we and should we not implement it?"}, {"id": 2166, "value": "Copy constructors don't have to take in pointers, it might be easier to pass a List object itself."}, {"id": 2167, "value": "For nodes in the middle (that is, not first or last node), the prev and next stores the address of the previous node and the node after it. . . For the first node, you should use a sentinel value for the prev pointer like a nullptr to let yourself know that this is the first node. Likewise, the next value of the last node should be nullptr (it could be something else if you really want to do it that way). If you point the next pointer of the last node at itself, you will never reach an end in iteration and it will keep spinning in circles if you are not extremely careful in your other implementations."}, {"id": 2168, "value": "We do have a memory leak detector for macOS! Check here https://eecs280staff.github.io/tutorials/setup_leakcheck.html#macos"}, {"id": 2169, "value": "Since Node is a private struct, it is entirely up to you to make sure all nodes are created on the heap. The user does not have access to the Node struct, and you don't have to worry about random creation of Node instance on the stack as long as you don't do it."}, {"id": 2170, "value": "Well, you are not supposed to use delete node_ptr, because node_ptr points to data in your list. When your iterator goes out of scope, you DO NOT want data in your list to go away along with it. In this case, you just want the node_ptr to die when it goes out of scope, which is handled by the compiler."}, {"id": 2171, "value": "I like how you're thinking, but I think the lifetime of a single request is more-or-less short enough that you can just keep them as local variables in your functions. There shouldn't be too many moving parts.. . If you decide that local variables are too small-scoped, though, your approach is definitely valid."}, {"id": 2172, "value": "For reasons that are probably covered in lecture, you shouldn't put templated classes in .cpp files. It can be a temporary fix, though, if you want some insight with squiggles and errors. Just remember to change the file back to .h before you compile."}, {"id": 2173, "value": "To rephrase the student answer -- yes positions should be \"updated\", but also note that you can get away with not storing position as a key in your student JSON. So it's going to be easier if you use the size member function of the standard library list and compute position whenever you need it in the response."}, {"id": 2174, "value": "Yup! That sounds good to me."}, {"id": 2175, "value": "You should read the entire request because if you don't then it'll be difficult to identify when the next valid request starts."}, {"id": 2176, "value": "You've mixed up your friend declarations. Remember, friend declarations should be used to give another class access to the own classes members. In other words, giving other people access to your stuff. In this case, your program is saying List doesn't have access to Iterators members."}, {"id": 2177, "value": "It looks like your List implementation is misusing memory somewhere. Unfortunately, we cannot tell what the issue is from the error message alone. I recommend running List_compile_check.exe under your debugger to see exactly which line the segmentation fault occurred on. You can also re-compile List_compile_check.exe with the address sanitizer enabled to get much better error messages related to memory issues."}, {"id": 2178, "value": "My web server froze upon trying to delete people from the head of the queue but passes all tests on the Autograder. Do you have general ideas how to fix this?"}, {"id": 2179, "value": "Mark as resolved."}, {"id": 2180, "value": "I don't think it's necessary to test it explicitly. If your program runs without Memory leak, then your destructor should be working."}, {"id": 2181, "value": "It's certainly a valid approach.. If you'd like to optimize a little, think about this: do you need to keep a position variable? If you do, you'll have to loop through the list to update them. If you don't, how would you get the position of a student? Is it worse than keeping track of it with an extra variable?"}, {"id": 2182, "value": "Instead of curly brackets, try using (). Initializer lists are for creating a constructor, not calling a constructor. Hope this helps!"}, {"id": 2183, "value": "You may need to change the ; at the end of the line of \"void insert()\" to { if you want to implement for it."}, {"id": 2184, "value": "You can just read everything through cin into variables as always. Just treat the http requests as strings in an istringstream."}, {"id": 2185, "value": "https://eecs280staff.github.io/p4-web/json.html#writing-json-to-a-stream. . ^ Take a look at the bottom of the \"Writing JSON\" section - there's a built-in length feature!"}, {"id": 2186, "value": "cin will know when to stop reading a request\u00a0if you read into a json object at the right time. You probably are trying to read into a json object before actually reaching the json part of cin."}, {"id": 2187, "value": "200 for ok, 201 for created, 204 for no content, 400 for bad request"}, {"id": 2188, "value": "Those operators aren't related to the datum associated to the node pointer, but rather the node pointer itself.. . In a list such as `[1, 2, 2, 3, 4]` if we have an iterator at the 1st location (first 2) and an iterator at the 2nd location (second 2) and we call the == operator on the two iterators, it should return false even though both iterators are pointing to two (because they are not pointing to the same node!)."}, {"id": 2189, "value": "When we write a JSON to an output stream, there are a few additional steps we have to do involving the dump function. Check out this part of the JSON tutorial. Also, be sure you are reading in a properly formatted JSON input."}, {"id": 2190, "value": "There are several performance optimizations that are made in the actual STL list that help the OH queue you implement run efficiently. Because of this, you are required to use the STL list in your api.cpp. Implementing List.h in this project is for the purpose of making sure you understand how a simple doubly-linked list works at a lower level."}, {"id": 2191, "value": "You always must define any constructor, destructor, or function within the actual class, but you may choose to implement them inside or outside of the class. Just remember to use the scope resolution operator if you are implementing outside of the class.. . ex.. ```. void ClassName::ClassFunction() {. .... }. ```"}, {"id": 2192, "value": "api.cpp is required."}, {"id": 2193, "value": "I've personally never seen this error before, but would be happy to look at it closer in office hours. Here's what other people seemed to have to say about this error.. https://stackoverflow.com/questions/64126942/malloc-nano-zone-abandoned-due-to-inability-to-preallocate-reserved-vm-space. If you are using xcode, the thread sanitizer option may be the quickest/easiest fix.. ![image.png](/redirect/s3?bucket=uploads&prefix=paste%2Fksz3u03vizw5m6%2Ff1a900215a503001223bd578e289019698fe2c0257f35341cf5662ce11c70328%2Fimage.png)"}, {"id": 2194, "value": "This is the dereference operator; it should return the datum of the iterator's node_ptr"}, {"id": 2195, "value": "The only two types of iterators we can directly create are begin and end, so make a `begin()` iterator and increment it until it points to some node in the list where you want to either insert or erase"}, {"id": 2196, "value": "I am not sure if there is a way to access your WSL files using Windows Explorer, but you can open vs code in that directory and access the files, just type in. . code . . in the directory and it will open vs code."}, {"id": 2197, "value": "Try double click on folder p4-webNEW in the pop-up window. I think it's not showing you that folder but folder Products."}, {"id": 2198, "value": "One characteristic of a linked list is it does not support random access, meaning that you cannot directly access, say the 5-th element, with lst[4]. To access a student, you will need to loop through the list and check each node."}, {"id": 2199, "value": "The same way you set any struct value. The Student struct is private to the OHQueue class, so there\u2019s no restriction on how you can access it from inside any OHQueue function."}, {"id": 2200, "value": "I had a similar problem. For me, it boiled down to having an extra getline() in one of my functions so the program was expecting an extra line before responding, but it never received it.. . So, look through the expected requests and make sure that is what your program is expecting."}, {"id": 2201, "value": "The list tests should definitely be able to run without compiling api.exe. This is likely an issue with the compile sources in xcode as you said. Could you maybe include a screenshot of your compile sources?"}, {"id": 2202, "value": "Marking resolved."}, {"id": 2203, "value": "The error means that there is trouble parsing the json input. It could be that the input is formatted incorrectly, or the way you're reading it is incorrect."}, {"id": 2204, "value": "From the RME:. . . Traversing a list is really slow. \u00a0Instead, keep track of the size with a private member variable. That's how std::list does it.. . . . So, keep a private variable. "}, {"id": 2205, "value": "Mark as resolved."}, {"id": 2206, "value": "list.end() returns \"one past the end\" of a list, which you correctly state is a nullptr. Therefore, we can't actually do something like --list.end() to get the last element of a list."}, {"id": 2207, "value": "To clarify, requests are read in from `cin` while responses are generated by you and sent to `cout`. So the response code should be based on the request code per the spec and generated by you, then sent to cin as part of the whole response."}, {"id": 2208, "value": "Try taking out the string cast. Other than that, it is hard to say what the error is with the information given. The correct way to store data can be found in the JSON tutorial. If following that formatting does not work, I would suggest either posting a screenshot of the error or going to OH."}, {"id": 2209, "value": "First, note that you are not using your own List.h implementation in api.cpp, you should be using the standard library implementation by including <list> at the top of your api.cpp.. . This may be the cause of the issue if you are attempting to use your own implementation as the following syntax should work correctly:. . .  for (List<students>::Iterator it = queue.begin(); it != queue.end(); ++it). . You could also use the auto keyword to automatically get the type of the iterator like this:\u00a0. . . for (auto it = queue.begin(); it != queue.end(); ++it)"}, {"id": 2210, "value": "If the request deletes from an empty queue, you should return the same error response as any other error with the 400 response code in the headers:. . "}, {"id": 2211, "value": "For the sake of the project, I highly advise against this. C++ sockets are... fun, to say the least.. . It is definitely possible to use C++ to run web servers, though. The vast majority of people these days, though, use higher-level languages like Python/Java, and people closer to hardware or people working with really time-constrained tasks would go to C++. Off the top of my head, you'll learn about that kind of stuff in classes like EECS 485, 482, 489, and probably most general MDE courses (you'll most likely learn about Flask/Django at least). My guess (only somewhat educated) is that most socket usage would deal with populating actual data variables instead of putting them into an istream due to how TCP/UDP works.. . Instructors, feel free to fix anything I said that's incorrect."}, {"id": 2212, "value": "Yes, but it isn't necessary."}, {"id": 2213, "value": "There is a \"Search for Teammates\" thread under the pinned posts at the top of Piazza. You might have better luck finding a partner through that."}, {"id": 2214, "value": ""}, {"id": 2215, "value": "The student answer is correct. For a more in-depth explanation on how to create JSON objects, check out Constructing a JSON Object\u00a0in the JSON tutorial."}, {"id": 2216, "value": "They're taken through cin. As always, you can read into whatever data type you want, and it will work as long as the type is valid for the input."}, {"id": 2217, "value": "Yes, the primary change is that you are now required to implement the driver file api.cpp."}, {"id": 2218, "value": ". . . . . . How do you write the function implementations for the Iterator class outside of Iterator since all the functions are declared as private? Do we have to directly implement it in the class?. . . . . . . A function being private does not mean you cannot implement it outside of class. It just means this function cannot be called if an instance of the class is created.. Yes, you can directly implement them in the class.. "}, {"id": 2219, "value": "nlohmann::json response;. . .... .... . response[\"results\"] = nullptr;"}, {"id": 2220, "value": "Since the autograder only reads select files, it would not be able to access api.h so, whatever you where thinking about putting in api.h, copy and paste it and write it at the top of the api.cpp file.\u00a0. . (below the includes). . Then just define the functions as you normally would, so. . in api.cpp. . . #include <whatever>. . class foo {. \u00a0 \u00a0 \u00a0public:. \u00a0 \u00a0 \u00a0int x;. \u00a0 \u00a0 \u00a0void bar();. };. . void foo::bar(){. . }. . int main(){. ..... }. "}, {"id": 2221, "value": "You don't need to know the internal mechanics of linked lists and iterators to begin working on api.cpp. You can use the standard library list as the students' answer illustrated---it implements a similar interface to vectors, including `push_back`, `front`, `back`, and `pop_front`. To begin with api.cpp, I would recommend writing the part that interprets HTTP requests (using cin)."}, {"id": 2222, "value": "It seems like the errors are resolved because it falls back on default values. Try accessing localhost:8000 and see if you can open the webpage."}, {"id": 2223, "value": "That seems reasonable."}, {"id": 2224, "value": "That's definitely a valid approach. You could also make a function in the OHQueue class that listens for and handles all requests. How you complete api.cpp is completely up to you. We definitely recommend making a class, though, since that will lead to cleaner, more debugging-friendly code."}, {"id": 2225, "value": "This may just be a quirk of your IDE. An address of 0x0 is synonymous with nullptr, so you should be all good."}, {"id": 2226, "value": "I don't think there are official lectures that you have to watch for Project 4, but I would recommend watching through Lecture 17 (Iterators)."}, {"id": 2227, "value": "You will not need to implement the << operator for Iterator. The compile check only uses cout after dereferencing iterators which will use the << operator of the templated datatype and not the Iterator data type.. . For example the following lines output an integer:. . . . List<int>::Iterator iter = my_list.begin();. cout << *++--iter << endl;. "}, {"id": 2228, "value": "You do need to take into account empty lists in the insert operation. Note that an iterator to the beginning of an empty list is\u00a0valid but it is not\u00a0dereferenceable."}, {"id": 2229, "value": "You can if you wish."}, {"id": 2230, "value": "The method is read in as a string, along with all the other strings before the JSON object (the words/numbers on lines 1 through 4 of a request). Then, once all those things are read in, you can read in the JSON object using cin (if you have to, based on the request)."}, {"id": 2231, "value": "It is the number of bytes in the body. "}, {"id": 2232, "value": "The required response for this request is here: https://eecs280staff.github.io/p4-web/#response-format"}, {"id": 2233, "value": "You don\u2019t need to know too much about REST API\u2019s to finish api.cpp. It looks very intimidating at first, but it boils down to the following:. . The program continuously requests input, which is always in the same format (see HTTP Request format in spec). This can be done just using cin.It then checks that the input is valid according to the spec. If it\u2019s not valid, it returns a \u201cBad Request\u201d, the format of which is also in the specAfter verifying the correct format, it handles the request and creates an HTTP Response, which gets printed to cout. We\u2019ll go over more about REST API\u2019s at a broad level in lab this week, but really all you need to know is that it\u2019s a method of computers being able to communicate information to each other wirelessly, where one local computer (the client) sends requests to the server and gets responses in return.. . For more information on JSON: https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/JSON. More information on HTTP: https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview#http_flow. "}, {"id": 2234, "value": "It\u2019s difficult to give these types of timelines. In general, we can say P4\u2019s difficulty should be on par, or slightly less than P2."}, {"id": 2235, "value": "The destructor is automatically called when the object goes out of scope.. . Clear() is not implicitly called.. . An example of a destructor. . class Foo {. \tint* ptr = new Int(4);. . . \t~Foo() {. \t\tdelete ptr;. \t\tptr = nullptr;. \t}. };"}, {"id": 2236, "value": "Yes, the part before the json ({}) does get read, but only the first two items (which make up the request) actually matter. The rest can be read with cin and remain unused. The last slide of the p4 intro slides in the faq may help with this."}, {"id": 2237, "value": "\"List_tests.cpp:87:25: error: variable \u2018iterator2\u2019 set but not used\". You have an used variable in your test case file, hence the compiler is giving an error."}, {"id": 2238, "value": ""}, {"id": 2239, "value": "Yep, you have to implement operands such as ++ and * for Iterator"}, {"id": 2240, "value": "resolved"}, {"id": 2241, "value": "I believe from my IA that it was said that it would be released after the exam, but I am not completely sure.\u00a0"}, {"id": 2242, "value": "Project 4 will be released after spring break. If you're really curious, you're welcome to take a look at past semesters' P4 spec, but keep in mind changes may be made until it's officially released. Unlike the past few semesters, we're also planning on having students complete the full P4 this time, instead of just the linked list implementation."}, {"id": 2243, "value": "yup"}, {"id": 2244, "value": ""}], "links": [{"source": 1523, "target": 1523, "value": 1.0}, {"source": 1525, "target": 1979, "value": 0.60813031926315}, {"source": 1527, "target": 1527, "value": 1.0}, {"source": 1538, "target": 1538, "value": 1.0}, {"source": 1539, "target": 1656, "value": 1.0}, {"source": 1539, "target": 1693, "value": 1.0}, {"source": 1539, "target": 1790, "value": 1.0}, {"source": 1539, "target": 1913, "value": 1.0}, {"source": 1539, "target": 2018, "value": 1.0}, {"source": 1539, "target": 2107, "value": 1.0}, {"source": 1539, "target": 2179, "value": 0.7071067811865475}, {"source": 1539, "target": 2202, "value": 0.7071067811865475}, {"source": 1539, "target": 2205, "value": 0.7071067811865475}, {"source": 1540, "target": 1540, "value": 1.0}, {"source": 1542, "target": 1542, "value": 0.9999999999999999}, {"source": 1543, "target": 1813, "value": 1.0}, {"source": 1544, "target": 1544, "value": 0.9999999999999997}, {"source": 1546, "target": 1698, "value": 0.6149927832902938}, {"source": 1547, "target": 1656, "value": 0.7071067811865475}, {"source": 1547, "target": 1693, "value": 0.7071067811865475}, {"source": 1547, "target": 1790, "value": 0.7071067811865475}, {"source": 1547, "target": 1913, "value": 0.7071067811865475}, {"source": 1547, "target": 2018, "value": 0.7071067811865475}, {"source": 1547, "target": 2107, "value": 0.7071067811865475}, {"source": 1553, "target": 1553, "value": 1.0000000000000002}, {"source": 1558, "target": 1656, "value": 1.0}, {"source": 1558, "target": 1693, "value": 1.0}, {"source": 1558, "target": 1790, "value": 1.0}, {"source": 1558, "target": 1913, "value": 1.0}, {"source": 1558, "target": 2018, "value": 1.0}, {"source": 1558, "target": 2107, "value": 1.0}, {"source": 1558, "target": 2179, "value": 0.7071067811865475}, {"source": 1558, "target": 2202, "value": 0.7071067811865475}, {"source": 1558, "target": 2205, "value": 0.7071067811865475}, {"source": 1561, "target": 1561, "value": 1.0}, {"source": 1562, "target": 1562, "value": 1.0000000000000002}, {"source": 1563, "target": 1563, "value": 1.0000000000000002}, {"source": 1567, "target": 1567, "value": 1.0}, {"source": 1570, "target": 1570, "value": 1.0}, {"source": 1575, "target": 1610, "value": 0.6398771166858557}, {"source": 1577, "target": 1577, "value": 1.0}, {"source": 1578, "target": 1919, "value": 0.6030226891555273}, {"source": 1583, "target": 1656, "value": 1.0}, {"source": 1583, "target": 1693, "value": 1.0}, {"source": 1583, "target": 1790, "value": 1.0}, {"source": 1583, "target": 1913, "value": 1.0}, {"source": 1583, "target": 2018, "value": 1.0}, {"source": 1583, "target": 2107, "value": 1.0}, {"source": 1583, "target": 2179, "value": 0.7071067811865475}, {"source": 1583, "target": 2202, "value": 0.7071067811865475}, {"source": 1583, "target": 2205, "value": 0.7071067811865475}, {"source": 1589, "target": 1656, "value": 1.0}, {"source": 1589, "target": 1693, "value": 1.0}, {"source": 1589, "target": 1790, "value": 1.0}, {"source": 1589, "target": 1913, "value": 1.0}, {"source": 1589, "target": 2018, "value": 1.0}, {"source": 1589, "target": 2107, "value": 1.0}, {"source": 1589, "target": 2179, "value": 0.7071067811865475}, {"source": 1589, "target": 2202, "value": 0.7071067811865475}, {"source": 1589, "target": 2205, "value": 0.7071067811865475}, {"source": 1594, "target": 1594, "value": 1.0}, {"source": 1596, "target": 1596, "value": 1.0000000000000002}, {"source": 1599, "target": 1599, "value": 1.0000000000000002}, {"source": 1600, "target": 1600, "value": 1.0000000000000002}, {"source": 1601, "target": 1656, "value": 1.0}, {"source": 1601, "target": 1693, "value": 1.0}, {"source": 1601, "target": 1790, "value": 1.0}, {"source": 1601, "target": 1913, "value": 1.0}, {"source": 1601, "target": 2018, "value": 1.0}, {"source": 1601, "target": 2107, "value": 1.0}, {"source": 1601, "target": 2179, "value": 0.7071067811865475}, {"source": 1601, "target": 2202, "value": 0.7071067811865475}, {"source": 1601, "target": 2205, "value": 0.7071067811865475}, {"source": 1602, "target": 1602, "value": 1.0}, {"source": 1609, "target": 1609, "value": 1.0}, {"source": 1610, "target": 1610, "value": 0.9999999999999997}, {"source": 1611, "target": 1611, "value": 1.0000000000000004}, {"source": 1613, "target": 1613, "value": 0.9999999999999998}, {"source": 1617, "target": 1617, "value": 0.9999999999999998}, {"source": 1618, "target": 1618, "value": 0.9999999999999999}, {"source": 1619, "target": 1619, "value": 0.9999999999999997}, {"source": 1624, "target": 1624, "value": 0.9999999999999999}, {"source": 1631, "target": 1656, "value": 1.0}, {"source": 1631, "target": 1693, "value": 1.0}, {"source": 1631, "target": 1790, "value": 1.0}, {"source": 1631, "target": 1913, "value": 1.0}, {"source": 1631, "target": 2018, "value": 1.0}, {"source": 1631, "target": 2107, "value": 1.0}, {"source": 1631, "target": 2179, "value": 0.7071067811865475}, {"source": 1631, "target": 2202, "value": 0.7071067811865475}, {"source": 1631, "target": 2205, "value": 0.7071067811865475}, {"source": 1633, "target": 1633, "value": 1.0000000000000002}, {"source": 1634, "target": 1656, "value": 1.0}, {"source": 1634, "target": 1693, "value": 1.0}, {"source": 1634, "target": 1790, "value": 1.0}, {"source": 1634, "target": 1913, "value": 1.0}, {"source": 1634, "target": 2018, "value": 1.0}, {"source": 1634, "target": 2107, "value": 1.0}, {"source": 1634, "target": 2179, "value": 0.7071067811865475}, {"source": 1634, "target": 2202, "value": 0.7071067811865475}, {"source": 1634, "target": 2205, "value": 0.7071067811865475}, {"source": 1635, "target": 1635, "value": 0.9999999999999999}, {"source": 1646, "target": 1646, "value": 1.0}, {"source": 1649, "target": 1649, "value": 1.0}, {"source": 1653, "target": 1656, "value": 1.0}, {"source": 1653, "target": 1693, "value": 1.0}, {"source": 1653, "target": 1790, "value": 1.0}, {"source": 1653, "target": 1913, "value": 1.0}, {"source": 1653, "target": 2018, "value": 1.0}, {"source": 1653, "target": 2107, "value": 1.0}, {"source": 1653, "target": 2179, "value": 0.7071067811865475}, {"source": 1653, "target": 2202, "value": 0.7071067811865475}, {"source": 1653, "target": 2205, "value": 0.7071067811865475}, {"source": 1656, "target": 1656, "value": 1.0}, {"source": 1656, "target": 1693, "value": 1.0}, {"source": 1656, "target": 1790, "value": 1.0}, {"source": 1656, "target": 1913, "value": 1.0}, {"source": 1656, "target": 2018, "value": 1.0}, {"source": 1656, "target": 2107, "value": 1.0}, {"source": 1656, "target": 2179, "value": 0.7071067811865475}, {"source": 1656, "target": 2202, "value": 0.7071067811865475}, {"source": 1656, "target": 2205, "value": 0.7071067811865475}, {"source": 1657, "target": 2109, "value": 0.9258200997725515}, {"source": 1674, "target": 1674, "value": 1.0000000000000002}, {"source": 1675, "target": 1675, "value": 0.9999999999999999}, {"source": 1675, "target": 1722, "value": 0.6080298044061482}, {"source": 1678, "target": 1678, "value": 1.0000000000000002}, {"source": 1686, "target": 1686, "value": 1.0000000000000004}, {"source": 1690, "target": 1690, "value": 0.9999999999999998}, {"source": 1693, "target": 1693, "value": 1.0}, {"source": 1693, "target": 1790, "value": 1.0}, {"source": 1693, "target": 1913, "value": 1.0}, {"source": 1693, "target": 2018, "value": 1.0}, {"source": 1693, "target": 2107, "value": 1.0}, {"source": 1693, "target": 2179, "value": 0.7071067811865475}, {"source": 1693, "target": 2202, "value": 0.7071067811865475}, {"source": 1693, "target": 2205, "value": 0.7071067811865475}, {"source": 1694, "target": 1694, "value": 0.9999999999999998}, {"source": 1695, "target": 1695, "value": 0.9999999999999999}, {"source": 1696, "target": 1790, "value": 0.7071067811865475}, {"source": 1696, "target": 1913, "value": 0.7071067811865475}, {"source": 1696, "target": 2018, "value": 0.7071067811865475}, {"source": 1696, "target": 2107, "value": 0.7071067811865475}, {"source": 1696, "target": 2202, "value": 0.9999999999999998}, {"source": 1698, "target": 1698, "value": 0.9999999999999998}, {"source": 1704, "target": 1704, "value": 1.0}, {"source": 1706, "target": 1706, "value": 0.9999999999999999}, {"source": 1712, "target": 1712, "value": 1.0000000000000002}, {"source": 1717, "target": 1717, "value": 1.0000000000000002}, {"source": 1720, "target": 1720, "value": 0.9999999999999999}, {"source": 1722, "target": 1722, "value": 1.0000000000000002}, {"source": 1722, "target": 2144, "value": 0.6255432421712244}, {"source": 1724, "target": 1724, "value": 1.0000000000000002}, {"source": 1725, "target": 1725, "value": 1.0000000000000002}, {"source": 1726, "target": 1726, "value": 1.0000000000000002}, {"source": 1728, "target": 1728, "value": 1.0}, {"source": 1729, "target": 1729, "value": 1.0}, {"source": 1732, "target": 1790, "value": 1.0}, {"source": 1732, "target": 1913, "value": 1.0}, {"source": 1732, "target": 2018, "value": 1.0}, {"source": 1732, "target": 2107, "value": 1.0}, {"source": 1732, "target": 2179, "value": 0.7071067811865475}, {"source": 1732, "target": 2202, "value": 0.7071067811865475}, {"source": 1732, "target": 2205, "value": 0.7071067811865475}, {"source": 1735, "target": 1735, "value": 1.0000000000000002}, {"source": 1739, "target": 1813, "value": 1.0}, {"source": 1740, "target": 1790, "value": 1.0}, {"source": 1740, "target": 1913, "value": 1.0}, {"source": 1740, "target": 2018, "value": 1.0}, {"source": 1740, "target": 2107, "value": 1.0}, {"source": 1740, "target": 2179, "value": 0.7071067811865475}, {"source": 1740, "target": 2202, "value": 0.7071067811865475}, {"source": 1740, "target": 2205, "value": 0.7071067811865475}, {"source": 1745, "target": 1745, "value": 1.0000000000000002}, {"source": 1755, "target": 1755, "value": 1.0}, {"source": 1758, "target": 1758, "value": 0.9999999999999999}, {"source": 1761, "target": 1761, "value": 1.0}, {"source": 1766, "target": 1766, "value": 1.0000000000000002}, {"source": 1767, "target": 1767, "value": 1.0}, {"source": 1769, "target": 2019, "value": 0.7071067811865475}, {"source": 1769, "target": 2109, "value": 0.8366600265340755}, {"source": 1774, "target": 1774, "value": 1.0}, {"source": 1775, "target": 1790, "value": 1.0}, {"source": 1775, "target": 1913, "value": 1.0}, {"source": 1775, "target": 2018, "value": 1.0}, {"source": 1775, "target": 2107, "value": 1.0}, {"source": 1775, "target": 2179, "value": 0.7071067811865475}, {"source": 1775, "target": 2202, "value": 0.7071067811865475}, {"source": 1775, "target": 2205, "value": 0.7071067811865475}, {"source": 1778, "target": 1778, "value": 1.0000000000000002}, {"source": 1782, "target": 1782, "value": 1.0}, {"source": 1784, "target": 1784, "value": 0.9999999999999999}, {"source": 1789, "target": 1789, "value": 0.9999999999999998}, {"source": 1790, "target": 1790, "value": 1.0}, {"source": 1790, "target": 1913, "value": 1.0}, {"source": 1790, "target": 2018, "value": 1.0}, {"source": 1790, "target": 2107, "value": 1.0}, {"source": 1790, "target": 2179, "value": 0.7071067811865475}, {"source": 1790, "target": 2202, "value": 0.7071067811865475}, {"source": 1790, "target": 2205, "value": 0.7071067811865475}, {"source": 1793, "target": 1793, "value": 1.0000000000000002}, {"source": 1796, "target": 1796, "value": 0.9999999999999997}, {"source": 1796, "target": 2038, "value": 0.6612465225335805}, {"source": 1797, "target": 1797, "value": 0.9999999999999999}, {"source": 1798, "target": 1798, "value": 1.0}, {"source": 1799, "target": 1799, "value": 0.9999999999999999}, {"source": 1800, "target": 1800, "value": 1.0000000000000002}, {"source": 1801, "target": 1801, "value": 1.0}, {"source": 1804, "target": 1804, "value": 1.0000000000000002}, {"source": 1807, "target": 1807, "value": 0.9999999999999998}, {"source": 1808, "target": 1808, "value": 0.9999999999999999}, {"source": 1813, "target": 1813, "value": 1.0}, {"source": 1814, "target": 1814, "value": 1.0}, {"source": 1817, "target": 1913, "value": 1.0}, {"source": 1817, "target": 2018, "value": 1.0}, {"source": 1817, "target": 2107, "value": 1.0}, {"source": 1817, "target": 2179, "value": 0.7071067811865475}, {"source": 1817, "target": 2202, "value": 0.7071067811865475}, {"source": 1817, "target": 2205, "value": 0.7071067811865475}, {"source": 1823, "target": 1823, "value": 1.0}, {"source": 1835, "target": 1835, "value": 0.9999999999999998}, {"source": 1836, "target": 1836, "value": 1.0}, {"source": 1839, "target": 1839, "value": 0.9999999999999999}, {"source": 1841, "target": 1841, "value": 1.0}, {"source": 1841, "target": 1858, "value": 0.6063390625908325}, {"source": 1843, "target": 1843, "value": 0.9999999999999997}, {"source": 1850, "target": 1850, "value": 1.0}, {"source": 1852, "target": 1852, "value": 1.0}, {"source": 1857, "target": 1913, "value": 1.0}, {"source": 1857, "target": 2018, "value": 1.0}, {"source": 1857, "target": 2107, "value": 1.0}, {"source": 1857, "target": 2179, "value": 0.7071067811865475}, {"source": 1857, "target": 2202, "value": 0.7071067811865475}, {"source": 1857, "target": 2205, "value": 0.7071067811865475}, {"source": 1858, "target": 1858, "value": 1.0}, {"source": 1861, "target": 1861, "value": 1.0000000000000002}, {"source": 1863, "target": 1863, "value": 1.0}, {"source": 1887, "target": 1913, "value": 1.0}, {"source": 1887, "target": 2018, "value": 1.0}, {"source": 1887, "target": 2107, "value": 1.0}, {"source": 1887, "target": 2179, "value": 0.7071067811865475}, {"source": 1887, "target": 2202, "value": 0.7071067811865475}, {"source": 1887, "target": 2205, "value": 0.7071067811865475}, {"source": 1900, "target": 1900, "value": 0.9999999999999998}, {"source": 1904, "target": 1913, "value": 1.0}, {"source": 1904, "target": 2018, "value": 1.0}, {"source": 1904, "target": 2107, "value": 1.0}, {"source": 1904, "target": 2179, "value": 0.7071067811865475}, {"source": 1904, "target": 2202, "value": 0.7071067811865475}, {"source": 1904, "target": 2205, "value": 0.7071067811865475}, {"source": 1910, "target": 1910, "value": 1.0}, {"source": 1912, "target": 1912, "value": 1.0000000000000002}, {"source": 1913, "target": 1913, "value": 1.0}, {"source": 1913, "target": 2018, "value": 1.0}, {"source": 1913, "target": 2107, "value": 1.0}, {"source": 1913, "target": 2179, "value": 0.7071067811865475}, {"source": 1913, "target": 2202, "value": 0.7071067811865475}, {"source": 1913, "target": 2205, "value": 0.7071067811865475}, {"source": 1917, "target": 1917, "value": 1.0000000000000002}, {"source": 1919, "target": 1919, "value": 1.0000000000000002}, {"source": 1923, "target": 1923, "value": 1.0000000000000002}, {"source": 1923, "target": 1961, "value": 0.816496580927726}, {"source": 1924, "target": 1924, "value": 1.0}, {"source": 1935, "target": 1935, "value": 1.0}, {"source": 1954, "target": 1954, "value": 1.0000000000000002}, {"source": 1957, "target": 1957, "value": 1.0000000000000002}, {"source": 1961, "target": 1961, "value": 0.9999999999999998}, {"source": 1962, "target": 1962, "value": 0.9999999999999998}, {"source": 1967, "target": 1967, "value": 0.9999999999999998}, {"source": 1969, "target": 1969, "value": 1.0}, {"source": 1971, "target": 1971, "value": 1.0}, {"source": 1972, "target": 1972, "value": 1.0}, {"source": 1975, "target": 1975, "value": 1.0000000000000002}, {"source": 1979, "target": 1979, "value": 1.0000000000000002}, {"source": 1980, "target": 1980, "value": 1.0000000000000002}, {"source": 1986, "target": 1986, "value": 0.9999999999999998}, {"source": 1989, "target": 1989, "value": 1.0}, {"source": 1990, "target": 2018, "value": 1.0}, {"source": 1990, "target": 2107, "value": 1.0}, {"source": 1990, "target": 2179, "value": 0.7071067811865475}, {"source": 1990, "target": 2202, "value": 0.7071067811865475}, {"source": 1990, "target": 2205, "value": 0.7071067811865475}, {"source": 1996, "target": 1996, "value": 1.0000000000000002}, {"source": 2003, "target": 2003, "value": 0.9999999999999998}, {"source": 2007, "target": 2007, "value": 0.9999999999999998}, {"source": 2008, "target": 2008, "value": 1.0}, {"source": 2011, "target": 2011, "value": 1.0000000000000002}, {"source": 2013, "target": 2013, "value": 1.0}, {"source": 2018, "target": 2018, "value": 1.0}, {"source": 2018, "target": 2107, "value": 1.0}, {"source": 2018, "target": 2179, "value": 0.7071067811865475}, {"source": 2018, "target": 2202, "value": 0.7071067811865475}, {"source": 2018, "target": 2205, "value": 0.7071067811865475}, {"source": 2019, "target": 2019, "value": 0.9999999999999999}, {"source": 2029, "target": 2109, "value": 0.7291530786306695}, {"source": 2035, "target": 2035, "value": 0.9999999999999999}, {"source": 2036, "target": 2179, "value": 0.6324555320336758}, {"source": 2036, "target": 2205, "value": 0.6324555320336758}, {"source": 2037, "target": 2037, "value": 1.0000000000000002}, {"source": 2038, "target": 2038, "value": 1.0}, {"source": 2038, "target": 2186, "value": 0.6039571739702033}, {"source": 2039, "target": 2107, "value": 0.7071067811865475}, {"source": 2039, "target": 2202, "value": 0.9999999999999998}, {"source": 2041, "target": 2041, "value": 0.9999999999999999}, {"source": 2047, "target": 2047, "value": 1.0}, {"source": 2053, "target": 2053, "value": 1.0000000000000002}, {"source": 2054, "target": 2054, "value": 0.9999999999999997}, {"source": 2059, "target": 2059, "value": 0.9999999999999998}, {"source": 2062, "target": 2062, "value": 1.0}, {"source": 2063, "target": 2063, "value": 0.9999999999999999}, {"source": 2064, "target": 2064, "value": 1.0}, {"source": 2067, "target": 2067, "value": 0.9999999999999997}, {"source": 2070, "target": 2070, "value": 0.9999999999999998}, {"source": 2080, "target": 2080, "value": 1.0}, {"source": 2084, "target": 2084, "value": 1.0}, {"source": 2085, "target": 2085, "value": 1.0000000000000002}, {"source": 2089, "target": 2089, "value": 0.9999999999999998}, {"source": 2090, "target": 2090, "value": 1.0000000000000004}, {"source": 2093, "target": 2093, "value": 0.9999999999999999}, {"source": 2098, "target": 2098, "value": 1.0}, {"source": 2099, "target": 2099, "value": 0.9999999999999998}, {"source": 2100, "target": 2100, "value": 0.9999999999999998}, {"source": 2107, "target": 2107, "value": 1.0}, {"source": 2107, "target": 2179, "value": 0.7071067811865475}, {"source": 2107, "target": 2202, "value": 0.7071067811865475}, {"source": 2107, "target": 2205, "value": 0.7071067811865475}, {"source": 2109, "target": 2109, "value": 0.9999999999999997}, {"source": 2112, "target": 2202, "value": 0.9999999999999998}, {"source": 2117, "target": 2117, "value": 1.0}, {"source": 2121, "target": 2121, "value": 0.9999999999999998}, {"source": 2124, "target": 2124, "value": 1.0000000000000002}, {"source": 2130, "target": 2130, "value": 1.0000000000000002}, {"source": 2131, "target": 2131, "value": 1.0}, {"source": 2136, "target": 2136, "value": 0.9999999999999999}, {"source": 2142, "target": 2142, "value": 1.0}, {"source": 2144, "target": 2144, "value": 1.0}, {"source": 2148, "target": 2148, "value": 1.0}, {"source": 2149, "target": 2149, "value": 0.9999999999999999}, {"source": 2150, "target": 2150, "value": 1.0000000000000002}, {"source": 2153, "target": 2153, "value": 1.0000000000000002}, {"source": 2157, "target": 2179, "value": 0.7071067811865475}, {"source": 2157, "target": 2202, "value": 0.7071067811865475}, {"source": 2157, "target": 2205, "value": 0.7071067811865475}, {"source": 2158, "target": 2158, "value": 1.0000000000000002}, {"source": 2163, "target": 2163, "value": 0.9999999999999998}, {"source": 2166, "target": 2166, "value": 0.9999999999999999}, {"source": 2172, "target": 2172, "value": 1.0000000000000002}, {"source": 2175, "target": 2175, "value": 1.0000000000000002}, {"source": 2176, "target": 2176, "value": 0.9999999999999998}, {"source": 2179, "target": 2179, "value": 0.9999999999999998}, {"source": 2179, "target": 2205, "value": 0.9999999999999998}, {"source": 2186, "target": 2186, "value": 1.0000000000000002}, {"source": 2186, "target": 2230, "value": 0.6451612903225808}, {"source": 2201, "target": 2201, "value": 1.0000000000000002}, {"source": 2202, "target": 2202, "value": 0.9999999999999998}, {"source": 2205, "target": 2205, "value": 0.9999999999999998}, {"source": 2208, "target": 2208, "value": 1.0000000000000002}, {"source": 2222, "target": 2222, "value": 1.0000000000000002}, {"source": 2230, "target": 2230, "value": 1.0}]}