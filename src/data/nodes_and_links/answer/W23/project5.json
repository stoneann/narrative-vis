{"nodes": [{"id": 2324, "value": ""}, {"id": 2325, "value": ""}, {"id": 2326, "value": "Since you're passing in the same node n again in the recursive call, how would data for the left and right nodes get copied?"}, {"id": 2327, "value": "That is a non-empty tree with height 1."}, {"id": 2328, "value": "Make sure your function returns a value in every if/else if/else block. Even if logically a branch can never be executed, it should still return a value because compilers don't understand logic!. . Example:. bool foo(int a) {. \u00a0 if (a < 0) return false;. \u00a0 if (a >= 0) return true;. \u00a0 // logically the code never reaches here but it should\u00a0. \u00a0 // still return something because from the syntax point of. \u00a0 // view, the code could reach here. }. Solution: either return some garbage value there or preferably use if else wisely. bool foo(int a) {. \u00a0 if (a < 0) return false;. \u00a0 return true;. }. or\u00a0. bool foo(int a) {. \u00a0 if (a < 0) return false;. \u00a0 else return true;. }. "}, {"id": 2329, "value": "See @3835."}, {"id": 2330, "value": "BTS Destructor?. "}, {"id": 2331, "value": "resolved"}, {"id": 2332, "value": "Just like Compare in BinarySearchTree.h, Key_Compare is the name of the comparator class. You could create an instance by doing\u00a0Key_Compare less;"}, {"id": 2333, "value": "The find function literally does what a contains function does. I personally use it to check the required clause in my insert_impl."}, {"id": 2334, "value": "The github link provided for the csvstream.h library (https://github.com/awdeorio/csvstream) goes into detail on how to use both. The first example shows how to read into a map whereas the third shows how to read into a vector (such that the order of values read is maintained)."}, {"id": 2335, "value": "You should insert in a way that preserves sorting invariant. Realistically, it is always going to be inserted at the bottom of some branch. If you use recursion well, there will be just a few if...else... statements and they are definitely manageable."}, {"id": 2336, "value": ""}, {"id": 2337, "value": "node->datum should work"}, {"id": 2338, "value": "\"The only way I can think of is to find the maximum element on the left side of the tree and then check that against your current node's datum. And for the right side, to find the minimum and check against your current node's datum.\" - This is exactly right, and the test case you gave is exactly why.. . Interesting question I found in follow-ups: max and min functions assume that the invariant holds. How can we use them for checking invariant?. A: Since we are using recursion, we are going all the way to leaf nodes before the recursive functions return. At the end of the day, we can always get a node whose left and right subtrees are both valid. Worst case: a leaf node always has its left and right subtrees valid (both nullptr). Then max and min functions work perfectly fine on this node since the invariant does hold.. Then your algorithm works perfectly fine on this node.. If the invariant does not hold at this level, then it will return false and propagates the false all the way up. Eventually the function correctly returns false.. If the invariant holds at this level,\u00a0then this new, one node larger, tree becomes valid, so max and min functions can be correctly used on this new tree. We return to the previous case, and the recursion continues working its way up. Eventually, it either hits a false somewhere in between, or has to return true at the end, validating the tree.. . In the example you gave, when you call max on the left subtree of the tree rooted at 5, it would correctly return 25 since that left subtree is valid. Then 25 > 5 and the function returns false."}, {"id": 2339, "value": "the functions are static so they can be called without an instance of the class. Plus the iterator class uses the implementations you write so you could check out those functions too. Also it is worth looking at the compile check to get an idea of how to use the ADT.\u00a0"}, {"id": 2340, "value": "Are you declaring the comparator as a private member variable?\u00a0"}, {"id": 2341, "value": ". Does this mean that if both testing and training files cannot be opened, we have to print the error message twice?. . No, we would print the error for the first file that fails, then exit. We would probably attempt to open the training file first.. . . Also, if the training file opens properly, but the testing does not, does that mean we run the output for the training, and then print the error message or do we straight away return the error message because one of the files couldn't be opened?. . In the case of failure, we would probably want to know early before we do a bunch of work and end up having to throw it away (like the case where we do all the training but then exit because the test file doesn't open). In other words, you should check that both files open before training."}, {"id": 2342, "value": "Personally insert > find >= check_invariant > traverse > everything else. All the other functions are pretty straightforward if you attended lecture."}, {"id": 2343, "value": "Thanks for pointing this out, we are currently aware that the Makefile does not support this and planning to get this fixed.. . For now, you can add the following lines to your Makefile:. . Map_tests.exe: Map_tests.cpp Map.h BinarySearchTree.h. \t$(CXX) $(CXXFLAGS) $< -o $@. . . Add these lines around line 38, between BinarySearchTree_tests.exe and %_public_test.exe - so your Makefile should look something like:. . .... BinarySearchTree_tests.exe: BinarySearchTree_tests.cpp BinarySearchTree.h. \u00a0$(CXX) $(CXXFLAGS) $< -o $@. . Map_tests.exe: Map_tests.cpp Map.h BinarySearchTree.h. \u00a0$(CXX) $(CXXFLAGS) $< -o $@. . %_public_test.exe: %_public_test.cpp %.h. \u00a0$(CXX) $(CXXFLAGS) $< -o $@. . ..."}, {"id": 2344, "value": "Short answer: no.. . From the starter files (comment on iterator dereference overload):. . \u00a0 \u00a0 // WARNING: \u00a0Dereferencing an iterator returns an element from the tree. \u00a0 \u00a0 // \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 by reference, which could be modified. It is the. \u00a0 \u00a0 // \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 responsibility of the user to ensure that any. \u00a0 \u00a0 // \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 modifications result in a new value that compares equal. \u00a0 \u00a0 // \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 to the existing value. Otherwise, the sorting invariant. \u00a0 \u00a0 // \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 will no longer hold.. As the developer creating this data type, it is our responsibility to provide an interface for the user. If the user decides to do something that doesn't conform to the provided interface, then whatever happens is the responsibility of the user (not the developer)."}, {"id": 2345, "value": "Since nodes are dynamically allocated, you should use the new keyword and put them on the heap. This also means that you will need to delete all nodes in the destructor."}, {"id": 2346, "value": "The correct output is... no output, haha. The compile check just ensures that your BST code compiles, and doesn't actually print anything. If you're getting errors when running it, that's a problem\u2014otherwise, you're good to go (with the compile check, at least).If you're actually looking to test your code, there's a basic public test you can compile and run (BinarySearchTree_public_test.cpp, if I remember correctly). On top of this public test, you should be writing your own test cases to submit to the autograder (you need to catch 16 out of the 19 possible bugs for your own tests)."}, {"id": 2347, "value": "The copy_nodes_impl function needs to return a Node pointer:. . static Node * copy_nodes_impl(Node *node)\u00a0\u00a0"}, {"id": 2348, "value": "Nothing stands out as incorrect for your implementation for the min_greater_than_impl function, so I am wondering if the issue you re getting is from somewhere else in your code. Have you tried writing your own test cases for other functions or stepping through the compile check using the debugger? Also identifying what line in the compile check is giving you issues would be a helpful start."}, {"id": 2349, "value": "Nodes are created on the heap (using the new keyword), so they must be destroyed in the destructor (using the delete keyword) : ) See the student answer and followups for more ideas on how to do this"}, {"id": 2350, "value": "I think this is an issue with converting the constant Node from check_sorting_invariant_impl to a non_constant Node used in the Max function. However, I also have this issue and need help finding a solution."}, {"id": 2351, "value": "Since the tree is printed using the ++ operator (I believe) something is probably going wrong inside of the \"&operator++\" code. This means your implementation of either \"min_element_impl\" or \"min_greater_than_impl\" is not working properly."}, {"id": 2352, "value": "You need to implement the \"operator()\" for the PairComp class in order for the code to compile properly.See\u00a0@3793 on how to use \"Key_compare\" inside of the \"operator()\" function."}, {"id": 2353, "value": "19"}, {"id": 2354, "value": "Did you initialize your left and right pointers properly?"}, {"id": 2355, "value": "It depends what you find challenging -- P5 has a somewhat similar structure to P4 in that you create your own BST and Map data structures, then use the STL implementations of those data structures for the ML driver. Generally we say the driver for P5 requires you to think more independently than the other driver functions you've implemented so far. . . I'd recommend sitting down and trying to put something down and seeing what parts may be difficult, and if you get stuck feel free to make a more specific piazza post or come to OH."}, {"id": 2356, "value": "Under the hood, the Map uses a BST that stores key/value pairs. Does your BinarySearchTree.h have any helpful Iterator functions you can call (ie. begin)? (it's simpler than you think)"}, {"id": 2357, "value": "In your impl functions, you should use the custom\u00a0less\u00a0passed in, instead of\u00a0std::less. Otherwise, those functions won't work for compile check since\u00a0std::less\u00a0can't compare two Duck instances."}, {"id": 2358, "value": "See @3764I'd also recommend looking at some of the lecture notes, as they cover it there too to some extent."}, {"id": 2359, "value": "It looks like you're calling the wrong function here; \"check_sorting_invariant\" is a public member function of your BinarySearchTree; the function you want to be calling here is \"check_sorting_invariant_impl\", which is your implementation of the sorting invariant check."}, {"id": 2360, "value": "It doesn't really make sense for a height/size of something to be negative, so we return a\u00a0size_t, which is always non-negative, to best represent the value.. You should always be extra careful to not assign a negative value to a\u00a0size_t, otherwise it will overflow and return an extremely large value. It also means that when you see a size that is unreasonably large, you should check if you've accidentally let it be negative."}, {"id": 2361, "value": "Answering my own question here, but apparently you need to use the following instead:. . Key_compare()(lhs.first, rhs.first);. "}, {"id": 2362, "value": "If you are asking about the number of keys in the map where you use to store such information, yes, as you need to iterate through every unique combination of label $$C$$ and word $$w$$."}, {"id": 2363, "value": "The requires clause ensures that no duplicates will be added to the tree. You don't need to verify this yourself :)"}, {"id": 2364, "value": ""}, {"id": 2365, "value": "Your implementation of \"insert_impl\" should return the root node, with all of its leaves updated to point to their proper children (including the newly inserted child). If your size is always 1 after using the included \"insert\" method, there's something wrong with your implementation of \"insert_impl\"."}, {"id": 2366, "value": "You'll actually need two recursive calls (only one of which will be called for each recursion, however). One goes down the left path, and the other goes down the right path. Think about when you would need to go down one path or the other, based on the sorting invariant.Once you've found the correct Node, it should be returned all the way back up the chain. You just need to determine when you've found the right Node (think about the difference between when you go left and find a nullptr, vs. when you go right and encounter a nullptr; in one of these cases, you've found the correct Node that should be returned all the way back up, and in the other you're looking at a value that's too large).It's also worth noting that you should return a nullptr immediately if the node you are looking at is null."}, {"id": 2367, "value": "You can always read the lecture notes for some pointers on a lot of the project-related concepts (usually only takes ~15 minutes or so, which is great if you're trying to get a head start). The lecture notes sometimes implement the functions you need for you, which is a nice bonus.I can't speak on the whole project, but for BST and its tests you really only need to understand recursion."}, {"id": 2368, "value": "The format \"less(thing1, thing2)\" should work to test if thing1 is less than thing2.\u00a0"}, {"id": 2369, "value": "The project is the same!"}, {"id": 2370, "value": "I recommend you read over the invariants for BST :)"}, {"id": 2371, "value": "The comparator takes in two objects of the same type and perform comparison based on the `"}, {"id": 2372, "value": "You only need the tag and content columns. You can use the provided csvstream.h library (https://github.com/awdeorio/csvstream) which allows you to easily read in specific columns and their values"}, {"id": 2373, "value": "I believe it's creating a new node structure, that is identical, but they are not connected in any way. The function is used in the copy constructor and = operator."}, {"id": 2374, "value": "You might want to construct your pair using this notation: `{k, Value_type()}` or use `std::make_pair`"}, {"id": 2375, "value": "If by max function, you mean a function that returns the datum of the Node with the largest value, then this doesn't seem helpful for the height_impl function.. Side note: if you did want to create such a max function, we would just have to find the \"right-most\" child. We can do this because of the sorting invariant.. . If by max function you mean a function that, given two integers (eg. heights), returns the larger integer, then this seems like something you may need. You could implement such n algorithm yourself using if statements or use std::max"}, {"id": 2376, "value": "I found this website quite useful:. https://www.fluentcpp.com/2019/10/29/stdless-and-its-modern-evolution/"}, {"id": 2377, "value": "I would do BST.h and then write your own BST_tests to heavily debug it (because the next part depends upon it).. I would then do map.h and then finally the driver.. Although the driver you will use the STL library."}, {"id": 2378, "value": ""}, {"id": 2379, "value": "Likely later this week or early next week after the end of P4."}], "links": [{"source": 2326, "target": 2326, "value": 0.9999999999999998}, {"source": 2328, "target": 2328, "value": 0.9999999999999999}, {"source": 2337, "target": 2337, "value": 1.0000000000000002}, {"source": 2340, "target": 2340, "value": 0.9999999999999999}, {"source": 2341, "target": 2341, "value": 1.0}, {"source": 2348, "target": 2348, "value": 1.0}, {"source": 2350, "target": 2350, "value": 1.0000000000000002}, {"source": 2352, "target": 2352, "value": 1.0}, {"source": 2357, "target": 2357, "value": 1.0}, {"source": 2359, "target": 2359, "value": 1.0}, {"source": 2361, "target": 2361, "value": 0.9999999999999999}, {"source": 2368, "target": 2368, "value": 1.0}, {"source": 2374, "target": 2374, "value": 1.0}]}